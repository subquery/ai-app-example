### PancakeSwapV3Factory  The core role of the factory contract is to generate liquidity pool smart contracts. Each pool comprises a pair of two tokens, uniting to create an asset pair, and is associated with a specific fee rate. It's important to emphasize that multiple pools can exist with the same asset pair, distinguished solely by their unique swap fees.  <!-- @include: ../snippets/evm-manifest-intro.md#level4 -->  In simple terms, there's only one event that requires configuration, and that's the `PoolCreated` event. After adding this event to the manifest file, it will be represented as follows:  ```ts {   dataSources: [     {       kind: EthereumDatasourceKind.Runtime,       startBlock: 26956207,       options: {         // Must be a key of assets         abi: "Factory",         address: "0x0bfbcf9fa4f9c56b0f40a671ad40e0805a091865",       },       assets: new Map([         ["Factory", { file: "./abis/factory.json" }],         ["ERC20", { file: "./abis/ERC20.json" }],          ["ERC20SymbolBytes", { file: "./abis/ERC20SymbolBytes.json" }],         ["ERC20NameBytes", { file: "./abis/ERC20NameBytes.json" }],         ["Pool", { file: "./abis/pool.json" }],       ]),       mapping: {         file: "./dist/index.js",         handlers: [           {             kind: EthereumHandlerKind.Event,             handler: "handlePoolCreated",             filter: {               topics: [                 "PoolCreated(address indexed token0, address indexed token1, uint24 indexed fee, int24 tickSpacing, address pool)",               ],             },           },         ],       },     },   ]; } ```  <!-- @include: ../snippets/bsc-manifest-note.md -->  <!-- @include: ../snippets/schema-intro.md#level4 -->  Now, let's consider the entities that we can extract from the factory smart contract for subsequent querying. The most obvious ones include:  1. `Factory`: This entity represents the factory smart contracts responsible for creating the `Pool` smart contracts. As of the publication of this page, there is currently only one active factory smart contract in use.  2. `Token`: This entity identifies the token entity, as Pools always involve two tokens.  3. `Pool`: This entity represents the XYK pools, which serve as the primary trading execution mechanism on PancakeSwap V3.  For these entities, the following attributes can be derived from data indexed from raw blockchain logs:  ```graphql type Factory @entity {   # factory address   id: ID!   # amount of pools created   poolCount: BigInt!   # amoutn of transactions all time   txCount: BigInt!    ...    # current owner of the factory   owner: ID! }  type Token @entity {   # token address   id: ID!   # token symbol   symbol: String!   # token name   name: String!   # token decimals   decimals: BigInt!   # token total supply   totalSupply: BigInt!    ...    # pools token is in that are white listed for USD pricing   # Should be Pool   #  whitelistPools: [Pool!]!   # derived fields   tokenDayData: [TokenDayData!]! @derivedFrom(field: "token") }  type Pool @entity {   # pool address   id: ID!   # creation   createdAtTimestamp: BigInt!   # block pool was created at   createdAtBlockNumber: BigInt!   # token0   token0: Token   #  token0: [Token!] @derivedFrom(field: "id")   token1: Token   #  token1: [Token!] @derivedFrom(field: "id")   # current tick   tick: BigInt   # current observation index   observationIndex: BigInt!   # all time token0 swapped   volumeToken0: Float!    ...    mints: [Mint!]! @derivedFrom(field: "pool")   burns: [Burn!]! @derivedFrom(field: "pool")   swaps: [Swap!]! @derivedFrom(field: "pool")   collects: [Collect!]! @derivedFrom(field: "pool")   ticks: [Tick!]! @derivedFrom(field: "pool") }  ```  ::: tip Note The attributes mentioned above represent only a subset of the available attributes. For a complete list and detailed documentation, please refer to the final code. :::  As you explore these attributes, you may notice the relationship between the `Pool` and `Token` entities. Additionally, you'll find numerous derived attributes like `mints` or `swaps`.  <!-- @include: ../snippets/note-on-entity-relationships.md -->  <!-- @include: ../snippets/evm-codegen.md -->  ```ts // Import entity types generated from the GraphQL schema import { Factory, Pool, Token } from "../types"; ```  <!-- @include: ../snippets/mapping-intro.md#level4 -->  <!-- @include: ../snippets/bsc-mapping-note.md -->  Writing mappings for the factory smart contract is a straightforward process. To provide better context, we've included this handler in a separate file `factory.ts` within the `src/mappings` directory. Let's start by importing the necessary modules.  ```ts // Import event types from the registry contract ABI import {   Pool,   Token,   Factory,   ... } from "../types"; import { EthereumLog } from "@subql/types-ethereum"; import { PoolCreatedEvent } from "../types/contracts/Factory"; ```  `Pool`, `Factory`, and `Token` are models that were generated in a [prior step](#2-updating-graphql-schema-file). `PoolCreatedEvent` and `EthereumLog` are TypeScript models generated by the SubQuery SDK to facilitate event handling.  As a reminder from the configuration step outlined in the [Manifest File](#1configuring-manifest-file), we have a single handler called `handlePoolCreated`. Now, let's proceed with its implementation:  ```ts export async function handlePoolCreated(   event: EthereumLog<PoolCreatedEvent["args"]> ): Promise<void> {   let factory = await Factory.get(FACTORY_ADDRESS);   if (factory === undefined || factory === undefined) {     factory = Factory.create({       id: FACTORY_ADDRESS,       poolCount: ZERO_BI,       totalVolumeETH: 0,       ...   }    let [token0, token1] = await Promise.all([     Token.get(event.args.token0),     Token.get(event.args.token1),   ]);   // fetch info if nul   if (token0 === undefined || token0 == null) {     const [symbol, name, totalSupply, decimals] = await Promise.all([       fetchTokenSymbol(event.args.token0),       fetchTokenName(event.args.token0),       fetchTokenTotalSupply(event.args.token0).then((r) => r.toBigInt()),       fetchTokenDecimals(event.args.token0),     ]);     // bail if we couldn't figure out the decimals     if (!decimals) {       return;     }      token0 = Token.create({       id: event.args.token0,       symbol,       name,       totalSupply,       ...     });   }    if (token1 === undefined || token1 == null) {     const [symbol, name, totalSupply, decimals] = await Promise.all([       fetchTokenSymbol(event.args.token1),       fetchTokenName(event.args.token1),       fetchTokenTotalSupply(event.args.token1).then((r) => r.toBigInt()),       fetchTokenDecimals(event.args.token1),     ]);     // bail if we couldn't figure out the decimals     if (!decimals) {       return;     }      token1 = Token.create({       id: event.args.token1,       symbol,       name,       totalSupply,       ...     });   }    factory.poolCount = factory.poolCount + ONE_BI;    const pool = Pool.create({     id: event.args.pool,     token0Id: token0.id,     token1Id: token1.id,     ...   });    await Promise.all([     token0.save(),     token1.save(), // create the tracked contract based on the template     pool.save(),     factory.save(),   ]); } ```  Explaining the code provided above, the `handlePoolCreated` function accepts an Ethereum event object as its input. This function serves the purpose of capturing essential information when a new pool is created on the blockchain. Here's a breakdown of its key steps:  1. **Factory Object Retrieval**: Initially, the function tries to retrieve a Factory object. If a Factory object is not found or is undefined, it proceeds to create a new Factory object with default initial values.  2. **Token Information Retrieval**: Following that, the function fetches information about two tokens: `token0` and `token1`.  ::: tip Note Throughout this mapping and those that follow, numerous utility functions are employed to process the data. In this specific example, these utility functions are stored in the `utils` directory. If you're interested in understanding how they work, you can refer to the [final code](https://github.com/subquery/ethereum-subql-starter/tree/main/BNB%20Smart%20Chain/bsc-pancake-swap/). :::  3. **Data Persistence**: To ensure the collected data persists, the function saves the modifications made to the `Token`, `Pool`, and `Factory` objects. This typically entails storing the data in a database or data store.  ğŸ‰ At this point, you have successfully crafted the handling logic for the factory smart contract and populated queryable entities like `Token`, `Pool`, and `Factory`. This means you can now proceed to the [building process](#build-your-project) to test the indexer's functionality up to this point.         d"      ›ªœr\ø¡?Jß¡±Á…¿G/Õ’¯€¯¿f½_Ÿ?ÌÌÙöÎL†¿™\ƒ)¢?¤öÂgbï˜?sAd.ü"…?G>eŞ§¿5¬±RÒ—?À+›œNp¢¿N§ã¡Ä¤¿áh#S¨?ó÷|S¬¤¿âøEt•¡?­ú}{®!¶¿¿•$ƒg8Ÿ¿¢èLñÄ¿7 aÛFn¿zNİ	´C¥?jŒ1Hf¿i­Iár¸¿¶L¢â(r¿Ø,ëC=Rk¿˜éo·È?ÌéïûğY’?‘ØŸüïn¿çùôT¨?-‚÷<¦¿%	>İ«¤¿]I’«?¯"'<6<„?"é±¬¥?5h” R4q?Ö4,œ]$¡¿ ±\*Ç¥?ŒˆœÆš?ñ9$s4x?¦
}ğ^u¿$P>-©®?–?ß,U?ó[X]¥À£?‰â<9–¹µ¿PV©,L£¿x)z‚ò‚¿AòÎ¡U¡¿€íã¨©‘?aÿD¢¿ë»@†ä?ÎÊ>2—”?|âa#®p¿Æú&7Š ¿Ü7ÎØ]Á¨?'¨<Ëˆ¦¿3a¨îd¶?š(´?_™’¿ÓÄ–yh”¿¨>ƒ’q¨…?½tLCx§‘¿ïì+´¤¿›®£Šp§?e‹zv¿az©·ŠŠ?ÔòÁ:'¶?_ êzµ?9
}¡aà ¿a=ä lo¿>;…ğtÀ?Û€šS¾¡¿qUA[º¨?ı(ÁÖı•¿52‚ïÄK?¨ğ`¾Îã†?jP4`‘›?d¼{º™Uš?ÆöY«V;¿É-…¾ö÷~?’ì®?Ë©¿)Mš(“¿¢ü–¿Çb¿ë>Fî§?î;rã—s¨¿QÕg{²j²?-ãg¢V8Œ¿š†^£­?Of|’MOn?Q÷à9„¿‘¿Fãkõ¨¿äú‡¿‰Ï ‹ºŞƒ?9×5úf¥?QÂÛÊåª?S&Œ’¿âµ_ÿôíœ?Iúé|Î–™¿¿ŞOtú‰¿rºíÁò‡µ¿Êh†á5[3?jA¡ş°.¿uæeçI¦š?†"ÁzúE¿yN£^*p?¼a_…p‰¿ª	&'¨¡¿5¬·{1ƒU?~DXüÂ§?n~ç
ûå¿¡V•÷3Â?O©Ø¹åú?Z$ğş­¡œ¿Öálcé£¿ü
Şÿã^­?VÅ2~Ü%Z?¤³å¿´f°¿Q‹¨İôm¿;Z>!±¿I¯Te)c¿³±Tê¿_¼ö7.©?g#ó¢Xi ¿İÁÛÅ,b±¿ÏÊ`E?,-Ÿ¼ú> ¿$ß
 r¿ƒĞ„ó—š¿„3tÃ!á¤?ÍP¹ââ’?9î„š?€u}Æ[¿·è›<°¿J…ÖŞ~t~¿ÈÏ% ²/Ÿ?\£í±WÌ–¿„%Lˆ!ˆ›¿˜>P{ú¿…,Ô Äüg¿d…g±¿yC·ê|p´¿aÀ³¹A’¿Ï;4}\s¿êŸfœS¦?šBuàæ¡?*9µ è›¥?ñÜµcnç¡¿Ä>""n«¿RH®rÓ,™¿ï''"ì¥?»Oeƒ‡§¿Òëæéñf?ºló”€?Ü\/_ô›«?ÀyÇâd§?4ªä™Êl¿âÀ®]û˜?ÌÏâÌ|›?¢Ì
­û¥¿?ä»Éä”¿]úŞy¾s•¿äı>7Â¿.øüÅï“b¿â+â½hd‘?ÖÚ›âè_£?}ı…(£íŸ¿Ş‚*¥?¦–R<Óğ¿Nús¸óP¯¿>1GØü›?FÎ—¨?çæÿ{1”¿Q4Òüx‚¥?!»3\âu¿aıÀÑeœ¨¿Hu\Ô¦¿K¾n€s?Z[€Ïr£?/:L@»_§¿_©xm€ãœ?'ıÑø×Œ¿µ:¿|@¤?Ã¥˜À¼?ú‚’Ù‹. ¿2}
Ûª—? ZzB$»y?·o’?H±®?cy_³a£?œ<õàŸf‘?ÎÂJ†¿fä${!pª?@H‹=ø¬¢¿nÑòÑ8©¿Ç}¡o¡£¿‚wå¿¯­¦¿¯é¨ÿxãg?'íxY4¥¿¥ëş»‚¥¿¿û}Û –¿Ïåıy¢?ù*xXHÃœ¿ÌçÃPÚ]¨¿2qU MÑ£¿q§Ò! Ğ«¿IKeq?ø(ĞåÕR¯?MŒÏŞÅm™¿MÜÁŞ"¶¿˜}ìÕ£?¥NO>ı€¿lı_;9¿¢¿Í­½Äùd¿V¸¤…İ­?ÈöºB¨¤?M•xßÌ	H¿Ãç0Z¥Æ?ÊøéF?ÆŸÜ‚"§u¿Y ßŞ‰¿;e.£jQq¿Áåø;ğ>†¿9‹†¨œØŠ¿ÈIËÂƒØª?»z
{’?ğ‚ıá+İ¨?³™ÅÙ¬?ŸhB†šŠ¿ñE³fï‚”?âÄn×ÿÄ?@ìu %U­¿Ã‹¶ìK„?ü]ò\s~?7±Ÿ lò{¿eçP]¡?ÚcşŞak¥¿ïMºÊfP°?Ó?Uûëz¿g³´\À?ü,ŸßtE¿ ¦z»P¿š»Çbª?áŒÌéÓ¦°¿ü®gK¿C?„„ëû·e–?ñŠŒ?¦ßá°«?ñÁ¥BÀJ°¿7€D46‘¿!Ä[î¢¿w‚¶.»¬¿ç«V¹_$Ÿ¿D«È%ä<—¿€ù£)´Š?{3-[2aŒ?E°ı¦¨á€?æd‚à™¿ª­”ByO ?TOÊÛ›¿áJnû»ÊŒ?[Ïs¸_?£µêµ……¿_yÒºôÌ ¿ÅÊhäóŠ¶¿ÌÊ$ZZ\™?efÇc“?>š€¿øV^Ñ1©?—äŸ!ì0w¿4“û_¦Ô±¿vy)+<’¿3=Y¿|š¿†éHf–?Ào«Í‘?-#;@»‰¿,TiQÀò¡?lÂ]•Â†¿YÿÚ]Şn¿y\­;¨0?a(¸<üSª¿@2>™m“¿`Ûª=O°§¿ªùMí:›¿õyCc§¿+ûÏçÚ?¼ÂC—¾w†¿LÄ0gƒ:?a‚T«+v¿ÈS–îœĞ}?æ~3£²Œ?óì£g;%’¿uvDÊ¾™?kzˆúèÊ? ¶;>6Ö¦?xĞ›s¸¢…?6­¹Ä¤?V¾*Á)F«¿‘ÚÛTj?e&¤w"o‚?¦><^‹?y)LJ²?kÌ5^“¡¿ãªY7C?*äİ Üƒ?šƒ
ˆõ¸R¿ `İ~bs¿\Ù`^¯?N¿ƒ ¹•ƒ?îè ÇÿO¡?ƒ†_]‹?€ûñœ»?¿n`\m‘¿ºöÀ6şª?j»KÚ;@¥¿^Ó(Éßb’¿œ„`ÂY+Ÿ¿S#f‰İ‰?³^»E;©?t¿ÎC)ş ¿ûUcÏ§?½•Û¬°Ï¬?¨rm·C’¿¡5X›s®œ?¯í€úµF•?x·á•ÓŸ?tZ6Á×ÚŠ¿†P£îÕ‘¿é¾|ÄE˜¿ORö¬ª?ÿL6~Şİ±?Ë)«0P.z¿§öÍĞˆ?hÿW«ãév¿v±m0ª¿eûóáf©¿EuÆ9âw°¿`ù"Ïe~?CãFßÖ5@?˜fíÈîˆŠ¿Ê!-¯ˆ¿X‹JHv5‰?ÇOŠ&µï˜?a$Êü‰¿#Ïıi‚®?’zÉâa‚¿”óæìtr¿({Õ½˜?çåMÑÓx ¿ ú\Pª6?oN^‰¤?{w·ô`9§¿«)İ ™?|‹¹1^oR¿£PÜ5¨ ¿3ØšÎÊ¥¿b—Ö‡?çŞ0Âõ×š¿v73 ™’?8à-o¡¿¥Öœ_ÿ¬?@âå¿j?®Œ¿}>§?1”—%Ï/©¿g¦Í›7–?›Ä~!th?	åf€W@©?=	Ê?Ã3¨?j†8üŒª¿¬!¦¯?Œ
¡K„R?ò8Ò:&b±?½éãƒ™š?šĞ£»±?AY!zŒÑ¦?»½>@åv?2…>À©û‡?uí÷®?1¿·;±Ü=?-ºÇb3q«?²n& Òá¤¿Ã–Q>šp‹?³…–Ü´—?{sÛe•?×í
…¿ì*Í{ÖŒ?!Ğôm?`´aŠ|c?]Æ^Åì`?ù@ÁàŸ¿ğ·‚Ã¯J¿fIœï‰”? »ábáy? Ãg®}p¿©ˆµ[¡¿äöì5©f?L| ?<G¶¿>³$@M-°¿@¿\|ër›?-œ—ÏaÚ‰¿ùC0ıh¿¬’#ø:‰?q/z¸.®¿ÛÂ¬}%ƒˆ¿I×L¾Ùæ«¿‡¢W;>å?3Ôé¿U>¯¿€FLız”?Éş’ ğ){¿`{Y~­¿“Èü«à°?¥ì$ğ{d¿Ğs¢ız¿¤¿ùÇ‡5?–&Bv ƒ¿ºÎ7HiF¿—¼:*¢?N¼Dœ¤¿ËÃÛw¿û,{„-…?ˆfsÜö+¿ÍhŸ*³?Á%¶qzÍ±?‡½¤¿_’?¸eÇ/¹‹¿á+É ÈX«¿ëĞÁï~£?½ôóÁR|¿Ğ.D&—?;éz+İ ˆ¿–9F· –?a}<è¡¿¤”keé—?©J0Ü†?›?nì]îY¡?G’lêFœq¿5A©ı£]›?ïõ¼zXE?ä¶cMÙ«¿JIãš?¾™YÊ€{¿¥–Cál¿şM¤–“?¹œE"F•?÷Úsf©_ƒ?|]És?æ¼ü×„w™¿øş¢õ{?…ú+Y°¿±ª‰ş¾t?Ã²Zßt¸?`Fƒ¤çÇ“¿(‘ûXìï›¿6[æŠ†¿+Û ¢¥Ìx¿Ü!˜x«?¹«° úÂz¿{ô_šs‹?[‰­Ú]2j?¿'òş!ø…?J;úz —¿ìM-×²ç¨?¥®jEj…a?@Üûrkª¿Urg‰B‰¤?iªHyá¢?~·€‰S“?J6hùË8¯¿Š¯|òÅY¿ònÂUO£?É‚\¾–?ì®Ãûj?4k¯Y¼Å’¿†¬dƒ)#”¿ZÇÍ}-@¢?ƒ™ßş–ß§¿Ô›0ålÏ¬?ß$YÉ¿}¬?‰&{DzŸ¿Ox*\fC¤?
g úS£?“”„Üö‘¿ˆ§ ÔO’?˜uü ù¤??Db”Ÿ?_;ŞÆÑ§?VÍ¦–¿¢¦
	«¿‘şÙ‡£³¿ !Á\¡?ôÉWğE¿°;A…ÅŠ¿“fmÿ< —?ÜîÌ¡˜şª?$??Æ»…¿„“ğaOk—?ZlÒî	r‰?^™£‚ë›¿A	$BÒœ¿äÌN½p•¿vWÒŸx4W?ß}~­…8´¿<–´ñ¤¿|åSS¢?jÈ@“?a”G‰Œ›?˜"sá›?›c¼9à ¿ıÆÒœ€Óp?[½`+ù ¿ƒïVÆa¿/ÎîA®ê~?È“jÀœ° ¿ë§)¬š¿s‘·ã±?VC²å4Â›¿
lç^Ô¬?ÎçàJ/£?«Ï%yÆgo?hUÔ+(¶¿`o€9É–¿^¶˜?ğšÑ;‡Å£¿%ÚÀãüÉ—¿FÏæ™Sš?I¦¶BŠ?å"³|Et?‚¸® ¿)0X\¥¿9§Ÿù~©?Ë•(!~–¿Ò•måC›¿W™çíß³¿>p¢Q£?iJnñIw¿Ùñ¿’4J‚?›8nç?w¿g	S?¬?£*Éác¨¿†c0[¿TŒ?VÏî©ƒ?ê.ı	6Ç¨¿NQ^ò0¿€Â{b+¿	|}¼¥?6uÒ†¹`‘?ÄÛŞŸ¿á§ıkf®¿Qw
§¸2P?7Í y·´›?)Õ'Èu¿9
¯J‘?'kP.Ÿ¿±·¡È^§?—x›’}„?],ş„í´?½jäA¤¿U‰ç©d¹?rn…C~¢¿ŞrŸcÚ¦?JÚòiÌ&¿¾âUHŒ­†¿‰=ö«çA?gÉ¢ä$ˆ¿‰:Zrh•¿q×6¸¹ š¿°„PŸ‚?{bÿ±ù˜?™+\á ¿—ÜQ1‹°¿	" ™í™¿sœÛ„{e¿DÊ‚İÉŞ'?CnU½´Tj¿Â‰:Dûb?v+ı “?m^Íèä˜µ¿Â‘‰YŠ?Ba¦¦ŠÍ”¿¥7úÈÁ–¿ûß†ò²–¿ŒUUøËØ˜?jªôë²’¿ƒ8jà¢î ¿Z›Ïó†¡¿­°³ı8U¨?7ª–”Ê·¿ª‹ˆ Ö4”¿¦WÒ£É£¿5Š_$‰—¿ĞêhEi™¿TµL¢8)¡¿ùTÀ‰?OÁ
…B©?(~=Ï˜¿p‹Ç_’š?@nfÄjË?İºûg?@¬KNlŒ…?)ù€\¼¨?,3/@¿8±ÑƒÌŸ¿Â™©Zß°?—M©à*.†?ÿ|†0±t?Õì¶H0‡?É¯âşj¨ª?›®R:‹ğ˜?j+›ŞjB?L¦gm?o‘¢TŸ?âJ?µ‹6†Ÿ?‰££/†ª¿Uä²ÿq* ¿{Wáì÷’??Fèƒ?¥•?‚Àı’ê¿Å”\†~ô¿§)9¡?Ôy¨ûm@e?«‡ıØ1£¿&•eÿ†¿0Ğ½ è.?Ù]8ÁK1®¿¯¢güÀ*¦?×ß= Ü>•¿bÆ†š?Ò3šäT”?Ò1Î|Z‡ƒ¿ùqÉ«Rş‚?ä YZ‹•¿›4;ÿ4¿èôş7İ±?Îûbc+”¿cİ ?2ò©¿:SAuª?€k‡¼nÜ—¿tœà=5Î¨¿ÿ÷R¡¿ijS!Ş¥?ëI ×æ°¿¹aÙ¡¡L¯?R{t—‚=­?Ûa7_1’§?'T£n~«?7áB	š¿î~f'»M¿ïiO	‡¿õKÄ[çß¡¿ŠV+i~bŒ?¿€À‰<«?SO¢€“p?V £ÑW{¿zs¡º‡‘?°:ùbê˜?D´úCcˆ¬?æGÓ³?€—&`ÌzŸ¿¿×È!æzu¿ÕÀ%¾v¿t[Ç])p¨?Ÿÿó;u¡?ä–Â“°¿C?ıœ?iàC2˜¿rO¸¡¿†!|lŠ¿éL9¢ä•|?Ïy±#L‘?%ÄdÃıôq¿ÁÔ‚Ÿ g?–áh\r»›¿W7æa¦¿ÏœÜŒ&Y¯¿è/Íœ	 l?Iú§`üP¿ÖïW;ie—¿®á)±Y˜¿'O¿‘ü—¿šAe?„ÔPçw—?î‹×şÆ…”?³ë%`P³¬?öºœ„|¿#î°ù‰¿ã#_’•¨?W@ãºH¥¿ö´˜ß6A†?Ï4š.ÿt?ê"ÇÎÂ;°¿O3`må¡?à(‹XJê¿Şø ˆÁÓv¿òÕ|ÿ`¤¿_rÖÑš?À>óŸY¸¿‘…g’†’?ù‘kÉœ?erŸYh —¿AÕK ¼±¿gÀ+Á“?¦Õ»8$Ç™?U©9vÙzi¿ã>Iì 3§?»÷cŸo's?ÁˆpïÁ¿m‡ráÁÈ“¿KÔŸy‡¿¨¦@@ .§¿õ‰íæ ?ø¬T§–™¿L0 ¤<-˜¿n'5¤¿SèÁè¹°?¬4£Ë†¿fEæ'[x\¿j®¯‚Ó©¿“õ™ˆ¾ˆ„?,£ËzµÌ¯¿ßîyzº?àŠ›…Bo¿e=ô^.B’?“ureÔ¥?uå6m?dÏ}½ë™¿¡L‚»Üõ¿ÆsÏq†š¿¬-dCÜh¿©)9ÙEˆ¿œÄ[C®–¿aĞVNŸ?‹Õ3üß|g¿#×¾€W¿Y!~/³™?50!éJ‘?ı¬oÜ’¿®ÁHı¯¿25fŸ¦O¿mã›â{Ã¬?-cÉpÊI‰¿ó >=‹­¿3K:~3'‹?pÙ¶b^Ë¨¿ï„²~ Í¡¿_n~cÒV©¿ŸDršâ?äÀæ‡5?ÒŞm¡?…¡¾¿âän??©h?ao‡?¨ÈLbCI¨¿8«p¢?]q«ÿ÷Ğ¦?+~ÇˆõŠ?ƒ”ha õ›¿qñÇÒ³¿K½ã¿€sèœ?@û‘"2¬¡?>Öû©Ë¢¿œÔXAZ¯¿Üß4Ø/3›?Õ»OÀ<…µ?‚Â$…GU‚?È‹Øiœ4 ?:Â¦ ?FqT°y¿ÖÄ	é
u¿äC”ì£?:\ô\ÂÄg¿7zbÁğV¤¿ABüİ¦?d"             t"                     ### PancakeSwapV3Factory  The core role of the factory contract œ:      Ü:      ### PancakeSwapV3Factory  The core role of the factory contract!ì:      ,;                      ”:             Ü:             ,;             v   
content ÿÿÿÿÿÿÿÿÿ*string8
3vector ÿÿÿÿÿÿÿÿÿ*fixed_size_list:double:7688j
lance0.17.0z
lance0.1x   üv ôt*l
0 ÿÿÿÿÿÿÿÿÿ*struct

null_count*int648
	min_value*string8
	max_value*string8 ¼vö;         LANC