# Multichain Quick Start - Plasma Bridge  This page explains how to create an multi-chain indexer to index the bridge transfer that are coming from Polygon to Ethereum via the Polygon Plasma Bridge. After reading this guide, you'll understand how to match the events across several networks and learn how to set up a SubQuery indexer to monitor, track and aggregate those events from different EVM blockchains within a single entity.  There are two types of bridge on Polygon for asset transfer, the Proof of Stake (PoS) Bridge and the Plasma Bridge. The PoS Bridge, as the name suggests, adopts the Proof of Stake (PoS) consensus algorithm to secure its network. Deposits on the PoS Bridge are completed almost instantly, but withdrawals may take a while to confirm. On the other hand, the Plasma Bridge supports the transfer of Polygon's native token `MATIC` and certain Ethereum tokens (`ETH`, ERC-20, and ERC-721). It uses the Ethereum Plasma scaling solution to offer increased security.  <!-- @include: ./snippets/multi-chain-quickstart-reference.md -->  Plasma bridge contracts have been deployed on both networks. In order to establish an indexer, we will need to asynchronously align the events from both of those smart contracts.  <!-- @include: ../snippets/evm-quickstart-reference.md -->  ::: tip Note Check the final code repository [here](https://github.com/subquery/ethereum-subql-starter/tree/main/Multi-Chain/polygon-plasma-bridge) to observe the integration of all previously mentioned configurations into a unified codebase. :::  <!-- @include: ./snippets/multi-chain-evm-manifest-intro.md#level2 -->  ::: code-tabs  @tab project.yaml  ```yaml dataSources:   - kind: ethereum/Runtime # We use ethereum runtime since Polygon is a layer-2 that is compatible     startBlock: 49174752     options:       # Must be a key of assets       abi: plasma       address: "0xd9c7c4ed4b66858301d0cb28cc88bf655fe34861" # Plasma contract     assets:       plasma:         file: "./abis/plasma.abi.json"     mapping:       file: "./dist/index.js"       handlers:         - handler: handlePolygonDeposit           kind: ethereum/LogHandler # We use ethereum handlers since Polygon is a layer-2 that is compatible           filter:             topics:               ## Follows standard log filters https://docs.ethers.io/v5/concepts/events/               - TokenDeposited (address,address,address,uint256,uint256) ```  :::  As you can see, we are only looking for a signle log - `TokenDeposited`. Data from this log will consequently be compared with the one emited in Ethereum network.  <!-- @include: ../snippets/ethereum-manifest-note.md -->  Next, change the name of the file mentioned above to `polygon.yaml` to indicate that this file holds the Ethereum configuration.  <!-- @include: ./snippets/multi-chain-creation.md -->  ::: code-tabs  @tab subquery-multichain.yaml  ```yaml specVersion: 1.0.0 query:   name: "@subql/query"   version: "*" projects:   - polygon.yaml   - ethereum.yaml ```  :::  Now, we have to find the contract and the event on the Polygon network, which data will be matched with Ethereum's smart contract data. The manifest file for Polygon will have the following look:  ::: code-tabs  @tab ethereum.yaml  ```yaml dataSources:   - kind: ethereum/Runtime # We use ethereum runtime since Polygon is a layer-2 that is compatible     startBlock: 18434359     options:       # Must be a key of assets       abi: plasma-eth       address: "0x401F6c983eA34274ec46f84D70b31C151321188b"     assets:       plasma-eth:         file: "./abis/plasma-eth.abi.json"     mapping:       file: "./dist/index.js"       handlers:         - handler: handleEthereumDepositBlock           kind: ethereum/LogHandler # We use ethereum handlers since Polygon is a layer-2 that is compatible           filter:             topics:               ## Follows standard log filters https://docs.ethers.io/v5/concepts/events/               - NewDepositBlock (address,address,uint256,uint256) ```  :::  Here, again we are relying to the data of the single log, `NewDepositBlock`. Both logs will be processed asynchronously, without a specific order, and will be matched according to their data.  <!-- @include: ./snippets/multi-chain-network-origin-note.md -->  <!-- @include: ../snippets/schema-intro.md#level2 -->  From the aforementioned logs the following entities can be derived:  * `DepositOnPolygon`: Represents deposits on the Polygon side of the bridge. * `DepositOnEthereum`: Represents withdrawals (Ethereum deposits). * `BridgeTransaction`: Connects Polygon deposits and Ethereum withdrawals. * `User`: Represents user data, including wallet address and total deposits.  ```graphql type DepositOnPolygon @entity {   id: ID! # Deposit Count Index   rootToken: String!   childToken: String!   user: User! # Foreign Key   amount: BigInt!   tx: String! }  type DepositOnEthereum @entity {   id: ID! # Withdrawl Count Index   token: String!   user: User! # Foreign Key   amount: BigInt!   tx: String! }  type BridgeTransaction @entity {   id: ID!   depositOnPolygon: DepositOnPolygon   depositOnEthereum: DepositOnEthereum }  type User @entity {   id: ID! # Wallet Address   totalDeposits: BigInt! } ```  These types help organise and query information about deposits, transactions, and users within SubQuery bridge indexer.  <!-- @include: ../snippets/evm-codegen.md -->  ```ts import {   DepositOnEthereum,   User,   DepositOnPolygon,   BridgeTransaction, } from "../types"; import { TokenDepositedLog } from "../types/abi-interfaces/PlasmaAbi"; import { NewDepositBlockLog } from "../types/abi-interfaces/PlasmaEthAbi"; ```  <!-- @include: ../snippets/evm-mapping-intro.md#level2 -->  Setting up mappings for this smart contract is straightforward. In this instance, the mappings are stored within the `src/mappings` directory, with the sole mapping file being `mappingHandlers.ts`. Now, let's take a closer look at it:  ```ts import assert from "assert"; import {   DepositOnEthereum,   User,   DepositOnPolygon,   BridgeTransaction, } from "../types"; import { TokenDepositedLog } from "../types/abi-interfaces/PlasmaAbi"; import { NewDepositBlockLog } from "../types/abi-interfaces/PlasmaEthAbi";  async function checkGetUser(user: string): Promise<User> {   let userRecord = await User.get(user.toLowerCase());   if (!userRecord) {     userRecord = User.create({       id: user.toLowerCase(),       totalDeposits: BigInt(0),     });     await userRecord.save();   }   return userRecord; }  export async function handlePolygonDeposit(   deposit: TokenDepositedLog, ): Promise<void> {   assert(deposit.args, "No args on deposit");   const userId = deposit.args[2].toLowerCase();   const userRecord = await checkGetUser(userId);    const depositRecord = DepositOnPolygon.create({     id: deposit.args[4].toString(),     rootToken: deposit.args[0],     childToken: deposit.args[1],     userId: userId,     amount: deposit.args[3].toBigInt(),     tx: deposit.transactionHash,   });   await depositRecord.save();    userRecord.totalDeposits += depositRecord.amount;   await userRecord.save();    let bridgeTransactionRecord = await BridgeTransaction.get(     deposit.args.depositCount.toString(),   );   if (!bridgeTransactionRecord) {     bridgeTransactionRecord = BridgeTransaction.create({       id: deposit.args.depositCount.toString(),     });   }   bridgeTransactionRecord.depositOnPolygonId =     deposit.args.depositCount.toString();   await bridgeTransactionRecord.save(); }  export async function handleEthereumDepositBlock(   deposit: NewDepositBlockLog, ): Promise<void> {   assert(deposit.args, "No args on deposit");   const userId = deposit.args.owner.toLocaleLowerCase();   const userRecord = await checkGetUser(userId);    const depositRecord = DepositOnEthereum.create({     id: deposit.args.depositBlockId.toString(),     token: deposit.args.token,     userId: userId,     amount: deposit.args.amountOrNFTId.toBigInt(),     tx: deposit.transactionHash,   });   await depositRecord.save();    userRecord.totalDeposits += depositRecord.amount;   await userRecord.save();    let bridgeTransactionRecord = await BridgeTransaction.get(     deposit.args.depositBlockId.toString(),   );   if (!bridgeTransactionRecord) {     bridgeTransactionRecord = BridgeTransaction.create({       id: deposit.args.depositBlockId.toString(),     });   }   bridgeTransactionRecord.depositOnEthereumId =     deposit.args.depositBlockId.toString();   await bridgeTransactionRecord.save(); } ```  Here's a brief explanation of what this code does. There are two main functions defined:  * `handlePolygonDeposit`: This function processes deposits made on the Polygon side of the bridge. It does the following:    * Checks if the deposit log contains arguments.   * Retrieves or creates a user record using `checkGetUser`.   * Creates a deposit record for the Polygon deposit and saves it to the database.   * Updates the total deposits for the user.   * Creates or retrieves a bridge transaction record and associates it with the Polygon deposit.  * `handleEthereumDepositBlock`: This function processes deposit blocks on the Ethereum side of the bridge. It performs similar actions as `handlePolygonDeposit` but for Ethereum deposits.  The `checkGetUser` function is defined to retrieve a user's record from a database. If the user record doesn't exist, it creates one with an initial total deposit value of 0.  ğŸ‰ At this stage, we have successfully incorporated all the desired entities that can be retrieved from Plasma Bridge smart contracts. Additionally, we've created mapping handlers is designed to handle and store deposit-related information from both sides of the bridge, update user records, and maintain transaction records for deposits.  ::: tip Note Check the final code repository [here](https://github.com/subquery/ethereum-subql-starter/tree/main/Multi-Chain/polygon-plasma-bridge) to observe the integration of all previously mentioned configurations into a unified codebase. :::  <!-- @include: ../snippets/build.md -->  <!-- @include: ../snippets/run-locally.md -->  <!-- @include: ../snippets/query-intro.md -->  ::: details Bridge Transactions         ¶'       âL7|n?èàÓ{®ß§¿.ò_Şë½Ä¿U†ÔaC?¥¿Ğº¸ jÁ¤?ZÍcb-™?é¬±¬}ÿƒ¿r_ã¢’¿öÍäÌá€¿tÕA $©¿®›¿úYÛ•?F¸$b¥]±?f¶uÜµ?«íÚ°6’?.–7H–?MËYéÿf²¿ºe¿¢æ¡˜¿Í*¦±AO¦¿Ø”ìWˆ®š?òæJÓ¤?¢ï;Îe¿oÌ>íÂ¿Q<±ä]i¿Wşª“›÷?f^XH
vĞ?ÌbFB³¢?iÒù2I°?Æ>$#7(­?”+B˜x¨¿nU cÍ¢¿ÌòĞÒp%Š?ÅÔ˜;ó‘¿]ü-}#w?ÄÅ=Õ¢§¿ûË-•”¿>`à˜¿C‡YĞm?eƒçŒ›? 3noY³¿Æ‡ ¡B£¿¢Êñ‰Ã9]?½â¨"õ“w?+O"6_;]¿íàğ¥_‡¿¡¹N#-•¢?Òb¦åîš?×ÀŞ¡5«?Ò¼õ÷Ø±“?œ´>D¶¯?•%Ã¼Š6¢¿9aˆ¢ƒ?;æÔêà•¿¬–~°ö¥?ÉUÖ}šo¨¿Î2‰‘°?ÉÈ¼w’?ƒœv\å˜?Û»íßHâ‘?"dı¿¿àcJ‘•¿˜L™Äîu©?r¦vw~ “?ÿ›c¼…¿Á«‚¤‘Ç±?Í¿:ç×—?jã¢Ş|¤¿œ(SÏêª¿l—ÄÆ­cŸ?Úı§œ¨‘?ÃâKT¡¿<’¢ ±?s>?À„¿,àO¡{U¤?dËí¼_•ƒ?o üƒ‘¿~åŞOÏ¿Ş'¾äÃ¿<A†óQ¿“UA§H›?Ç“é?‡Ó¥?È«£ıa¿f&Û¬¿J¢ªw¸?o
êt[¿ìÛøüø—¯?OÃüÆ”?ıDw¦V³|¿`fä›‰Ã›¿<Š‚ÿş§¿d›Ià~|?˜ÿæ~´#?±1g¿»rI“å²?dKkàa ?ú|RõD:µ¿ÈÓà ›”¿º8¸‹¿#´«± }±?ƒ«UQ_¬¿´N Âğ“¿[7EJ*ˆ~¿8bîÙÁ(?¡Ó¹Ã¢ùª?Ğ„`4¯˜¿Ü¶º_¯÷¢?!3aEW3|¿ ª˜jU£¿İªB­°ª?şF`»¢¿ "w	5à‹¿W÷æ<î©¿¢æ— }Ô­?Û+Õ £¿š)ÀŞè ¿öõ<Î •?¹ß½}ÿá§¿Ä †NSô™?¸Ğ]^õŠ­¿¦Í›7î¢?ÕıJ„™ø•?Ì¼>;,I’¿qã\£Ú©V¿fƒ;½úK~?ÒÜ }ì±?Eı½øÈt¿v¾#SÓ£?ôz¹£¿Vù$Ë×š?Ò5ö™q"“?\–L¡57ª¿.Â¢à1?
ß:€÷î’¿«Ã*°?İ¼Ö}†?/Ğú£?,¯üünïŸ?Á
 nY‰¿œıbeª¿•Àÿ¹Ü?0^Ş¡Â\?(>*=TÌ©?Sï «˜ w?Zšmh¯’?[”]Y7¡¿ÎQĞ¸3½“¿j¬l;GÆ¿bÉòÖBŠ?™dGW§Ò¢¿—Fpé©¿z¦gß´—£?é¼h½O½?5êÁ§°‡—?ÛéZ½»|’?œkßv}s¿XÏA~ÓG¢?xú÷Ï‰°¿ ÿ®Xs?Ì.}‡Yj–?Ì÷‚ÃÉ•¿´TİiKz?¥LD¡`$¥?â•YÁÅCŸ?¨?5=¬`²¿ß¾v¨s¬?Mk­¿µ;và4.°¿tÒAnñ¿6yú£Ğû®?™rZ@|jz¿D¨—5‹?ÛvT# ¿×uD~ß¢¿G.j½ w–¿3?jh¿0ë¬³­¨²?Cÿ\Ê6m¿C|7HN?§Ë~·",€¿©şvTr?b¥@nØ«¿M^Keİ¿ T‹ƒ©8­¿s™=Ôª?Mö®Å—•?$Ÿ@ ÷®¿1àK2‰²¿è„^i¶”?‚’Xƒ¿Öp‘{ºº¯¿Vh93n¢¿'L¹bIp¿&ú dû{¿)¯#{uoœ¿1œTü+ ¤¿ç²êÖßĞ²¿®¨w§ñÁ‰¿ë(ÿAÁ?ñ(ù?eT?—N#árš?–ø¿F‚¿[ÖÂEr¿â°uÖÛP¿{¡Q ¿è¥á™)”a¿û–N³¿ş<‡ŞT7¢?g;ˆ˜pº…¿4!¦wbŒ?˜ŠK]K+j¿=x Ä+Ï™?KE:n¾2±?©ÏJdc¢¿Ó‡ÁA_¿9mKz?<.¯”?t°ËÆ¿s—Ñƒµš¿8o¿×k±¿ah†}Ğ¥¿§(È:ø>9¿:¢` ? phœÿ~?îZ½:ü£¿5LóâR©¿C[Á{¶*“?RaÅŞÈ?7V'…Çgc¿İ¨Ô÷a0?•’í•ÜÕ•¿– uC	éŸ?ıÔ¦!Ô©¿~’–%•„¶¿Afã˜—‰¥?YÙ«ú†?‚‚×™–?>Şb€o“?•:8@?)5ƒ^/Ÿ?ÇúÈ¿‘¦T"=‡Q?Íÿ¹×Q°?"Ã&—?¸qZx?Xå¯?¬~`°¿£|/(M/›¿şsJ ¾î³¿wßôØİÖ¿ß¯<'A¨?6,°A{­?Ü	3Ãÿƒ¡¿›^Âÿé—¿³Æê \d˜?;[^¾—ğ­?m/*(“º‘?b`ã†fª¿ön ~'¤¿;7À/¢­?›?Û§92Œ¿q°’ê–x£¿N%E\ç|¡?½ß"šº—¿12·1,5™?99¸~>í­¿#.eØg¿dç¯ˆHê¿®øÀmñ¦¿Z.Ù€!–¿TÖÛsT¥?ˆÔË'ß÷…¿ßÊ›Œ×a?xÜZ ‰"›?€t^!{Ö€?s­j+g³?ušDí–¿ç` å%q—¿õİæC«?Cgá+6‰?ÖYØô–?”òbz%=r?¡¿By.rœ¿.Ü«‰vM"?c»”×Ÿ¿÷Pïf?IÑÜ |•Œ¿Èe€Ê!¢?Ç-2’?ÙY£\”?F«üÈ3£?Õæb€÷…?¾kL_:s¥?=å£Ìwu¿#f‰İ]¸¤¿Ç2XÌc(¦?ÿ7%¿ÉA¿ øÀªT¥?Ë$>Š‰¯?9YVÙøÅ—?¡x³æu?Qƒd_„¹‡¿ú×¹ûqúh?[UÀFn?S«Jƒ$±¥?Vœ‹;µe~¿œ±ûTíK¿º@˜ÇÙõ¿‰k¾ï;t¿JÑˆ¡îf ¿éF8;¡?	ğŠcY¿×Ùeÿ	—¿¯Sû`X¢?G¨é/”š¿[­¸İpÄ²?øzk2 ¿;§ì¯ç’?£>ç¼¯Ûz?÷r-Çå?†l¤•æ£?:IÎÜV?”½€Döq¿™™‡ÿü†v¿}væ<h ?.:›†%¡¿&#ÊBëÍn?™í!&Ş—?UK0XN›™¿@“Şæv÷œ?°f74Zƒ?
°—¿¥«¿¨´4¡ ¿/¨ŸÒé¤?xé‰[Ãš?<wÌŠò§¿È‰1²B¿ y­BÒÀ±?ã>D3ç§¿$zM¿=©}Ú«6?(üÆ•‚‡¦? WI\®°?AÍ|F£´w¿Yø]…Rƒ˜?Få)"ø¨¿˜®b™?ï•APÏ­?wK´Ü€l…?-< *ŞA¿ÑW¬»[T•?<4Äbè™™?š¿ SÏ’¿Ì«ĞÁ¬€?=‘’äÚÌ¢¿®µ:`[SF¿vò3?H`£?M?äí£7?YÙèãt†?6^‚Ÿ­?–îqP	‚¿§ª·£‹¢¿ï»u@
…£?oÁØ–ƒ¿¿¢×vE¶œ?Ê{Ú:òc¿9–_şÛnM?‚W&W?	§&=ã-¥?po{Óu?4Aeà¦]­?õYÕúqçq¿rz@ŠNƒ?½€êa`Š¿¯¼HÀ½œ?cï:Ç)g?6sÑ[ÿX¬?Ïí£â¥r?îH/IéÂ­¿+¢Úk7¿,ÏÒˆ<¨¿
Â“aN¬y¿uòE"I¯?ìéU*É¶ƒ¿ó‘}X»¤?’Nò])Ï°?V³Û"Á8–¿--WbI?ëgZo?'€# †…™?cDÍPãs?‚¨şoo¿ûq‚	g¿ñ†>œãƒ ¿Q…¢íV«¿Ír2¡ä6§¿DvRz¤œ¿”ÓY¤¿¤Èàà–?=°ƒM’¿“-~’¼¡?Oˆ]4”u€?.¹*lŠŒ¿%u#¨ñª¿'FaÚáöf?çÍ,{z¿úcÖb"kz?cíô%I?Tìö}âşg¿¿&1)º§¿ÍÁŸä…¡?FĞæ!d³{¿^ÚTë=?× â»?(h¿_ırBõÊª¿}goèo”¿MªlÆ>?ùˆVöv®¿5èëüRtª?¸V»Çí•?ás{×Ì‘¿S»j@‘?Jô®QA ?ÀS•E€?&g§mc¶‡¿uÇb›T4 ?%7€:Âœ¿j]m<Uª?ğwZÿôh¿°f~ä¿?Â5<xÅ†?L …è¥¿Š¥rbiÊx¿(½²•’?>÷l½©¿Ÿ?^Ör!xF?êNF.£d¿L¨½}¤?äşúSp™w?¨<Ãvª?Ÿ)	Ã_ ?hĞ&@z®Š?T
ÁrĞ ?å¤†Ï ¿½B„S?ÖÅ´	?Òıœ‚ül­?¹N†WP »?Î¢Jt¦?¼!gCùà¤¿=İ½ÿ6[¢¿Ë_çÇÛ›?ûPÿß,³…?˜LÎ¶¾;†?39uaÄ·i¿õÈ ÿ}›¿aÿT`ñiº?»şHïSŸ¿ÅÅ0« “¿'6›âş¤?%Eÿ}&‚?`l+¡ı ?S|/ÒL?0¿¿âA¿~*<¢!g¦¿q<´ ÓR¿Zæ˜Ä=œ¿•&âôh?z‘#cÌ‰¿ö¬”3N"¢¿0Ï™ ÅÓ¤?ÜùŞÜè.¨?6çÛà¼³¿M9ÓBÑU©?­\ şO“?õLã¢PÒ”¿®d¤îìj?äƒ\±Ø‰¥¿ü$Ågµ7—¿Ú:â=‘¿3\É ã(‰¿­†Š<t¿¦¯iZğÆl¿!F“¿<™¿İğX¿Û´«¿’$eâ¯¿rª1øf‘¿$Û8ã­›?²?(¦²}¿ŸÙ¾‚_¡?«Èô¡?ÇlÁ9ÀŒ?=8ş4”?Úç¼J–?Y¼•{:„?öÇ¤Tü¾‹¿YVÿ¿h‘ˆ¿ÃÎÚ%ƒ¨¿õUÉ2Š²¿U|*Dj¡?æä«¿
T?õ‘z ,´‰¿Êœ¼~À t¿7üi¬¢?|LFÃ™Ç£¿¹mY[`?jğç©Hd«?›~?ëĞ¿N×`ww¿:-3ıö›¬¿P­:‚†±¿Éğ&_Óú|¿nå€¸–¿1Dà{U{?ÀPü"åJ ?eãâ$¤ «?’á…˜³?»ş/X©¿Û	aûê&š?Äˆg$Æ™¿|sŸ¥¨¿†pqù´/¡?‚iÿ šr?ğ€Wpä&§¿dšüÇ ¥¿—ß€ÎX§¿µD¿š)Ë¿X
„‚2Ëv?VFµİºs¿ùa)7ö‘¬¿|ö·_™Œ¿XQ¢¼É¦¿PLõœ¨0?7µ'ÙÎ™¿Pş†:ÀT?Ú¶{ûŸ¿19ÃÚ‡¿Xl8ÑS›¿éd<YPi‡¿et s¿$?ô:hÊœ¿hEğ(¾«?•ZÑáı˜?¸g}ÜUx¿yC·ê|p•¿œh¯òt¿[‚8|œ?45…¥ìº’¿ôy(#‘º¿±ãW]›N•¿rÑBb¸Ã¿°è^J¦¿QR¾ê¥?ˆåCª¿Õ&w¥›?—`'+·¿M)¼¿Òİ‡?XÜ†`;¿–æûN8`Œ¿QÉWâjd?z¦*|œº“¿pr9
‚œ¿àØdll«?sÍ¼ÓŸ(?*¡L‡t––?{Ä´£»Zl¿#4¼v¿Ş§âzŸ €¿?2~w¿¢`ì«…?óŠ­[ôÔ$¿œÍ™£}b¸?}0+?iÛ¿ı@È„°¿L¤ÙáT’¿‹T¸Ÿ¼áx¿¥wÄıTĞ‘¿âì'z“¿®Kš±²f¿dÎY½È¦r¿·7*ı¥Á–¿Ób•wzJ•¿X×ù›vO¦?L‡<½¢¿Ì!Şúun¿î Fmºt¿´êW`æ@®¿ü~Php““?t†B¹–¿™ÖèÍ\³¿ã×Y>Ü§?rë.ƒC­¿&/È»’?ê">İdG¤?³TÙ¶’¿kj>†EGe?ˆÏ;-?AßZIÒ?Ï˜07k2“¿wA&¯?PB¥°`¿9%û³™¿ ¼J{"Oc?ra
úşp¿Ò|!&ÙÑ±?’ÃÜ|G7h¿Oc™ƒB2¡¿—Ò§Øµ°?YêØ—£¿èíá(ÿœ?¹Ä–ÀÛó¢¿@hÁ´=´š¿_å²Ì€…ˆ?¤ğuy¡?yJ/³Íb‰¿¨ï_'(I?í¿.ÀÇ+Ÿ?ïéEH8±¿ùş<²®?kCÀÅª­¿§¨-‡s“œ¿N‘/àæ™¿? &íiv?eJ˜±¿ÄÚ\XŞ%’?õCyÚr–¿ ö¸‹“°?âÃ·s¤¿“ èOU€²¿Ì…ÌÀÁ”¿à‡AhVj?±–´B6ª?Åü§ŞÄ×¿œšùEqİ€?/to°ı±¿)/ZÉŒ¿d˜Ñ©¿R° IÊ™?lÃR2¿Q`œ 3©?•¨ı'–“”¿¡ø1æ®%¦?ÒÃĞêä¥?ŞA9ğ»’¿2A´&{#—?½öÙ¼Ÿ??y/)“±?* ‚¢` ¿ãP(-ù‹?84ëàî’?d9»ê>?Ğãıt¦¿C¸}“€¯?­vkÅ€°?¨ÜÁbm@n?Ç‡´f¿é‹R|[4£¿e/ƒ"÷Ÿ¿ÓÓ)ŠµÊ|¿Ÿ©£UÀ¬¿˜UTÔËµ°¿ØîóŸ~†¿ÅÇi€¹³„¿)û'_ …¿Ó¤¶zI¿²
‡G%‘?Q2`¦?V<Í€µ•­¿´Í*¿Nâ†¿¿U’Í9…¿¢D	}…±¿’äJ„ˆ¿3=üì6¡?‰·fÜè$Š¿8dÉ=Ù¤›¿$Ó¡Óón®¿òµbİJ?¨¿»÷Ì¨?–(”èÙj ?D&›‘’‘?z+¼À“©?ê:«Á|z¿YR¿#<•¿EŒ©„¿œ?Å’Ã>9¾¥?BuiDl–¿a6éÄJ6j?•w)tP©¿Ëv¡şÑ¤?÷‰ÈI‡[?àgc„ã§¿#O	½;ˆ­¿â]}ßğ l¿!ëünÉ¿nØ‹6¤?Ÿu³]¦È¿Ü¡İøEÏ†¿=EÌôda„?íV!â-ŸG?V‹ Mšd¿{êyUA¿…õsïeŸ?qM„„]Qœ¿ÂtkË~?É†=¸m¿‰¾%zÅ‘?^Oú˜Í—¿mY Ú\Ÿ¿Â–GÌ&Ÿš¿&};8ÁŸ¿HÊZf¸Ñ¿ï‚?şı"s¿`Å~•™¿	¿@Gq?8ğXd"Š?İUY%¢©´?Ç4O…ª^§?K%÷xƒ?7üÛV”Á†?ÅU?s©¿>¾^‹?Ìí«¡şw?­{â;\“?ğ•ëz’?³¸Şº‹Å°¿¦Nz¾êñ”¿Lë¸ßv¨¿Ã!Gìà?´Køş6&¨?ïß@q•a§¿Cî;éñ9Ÿ?ğ'•¶ÙÔˆ¿ï“ŒdÛŞx?ş%s†<¿"§ñ>Ü™¿hq—6S~¿hçU^o?#WìZ;„•¿ARg•i“¿ü†»u¥f¿_Å×®‹?â>£ÉY?4ŸV=—£¿WØ	¸²œ?#|jZ¡?‡ÜÅaTE¬?Dš4ê?L¬J*li‚¿—ÉÁƒ¿<a€
­?2ôn}o’?{idx=ƒ¿
†ÉìŠ¿^JNCf¿ Ñ†ïÀi?Û+w±?·­?Éê¢¿òÿ§ıö7|¿AÎ¥ÿx®¿›Ï†êPŸ?¨éŠ„|ñ¼?ä)q>ñs˜?…è"ÎP˜?›[7Ú÷En?îs¯¥İn‘?Y3~V£›¿f¦
ÿOé—¿ê¢…ü”¿®íãÎp©¿V{ÉX¿¶'             Æ'                     # Multichain Quick Start - Plasma Bridge  This page explains howî?      .@      # Multichain Quick Start - Plasma Bridge  This page explains hox>@      ~@                      æ?             .@             ~@             v   
content ÿÿÿÿÿÿÿÿÿ*string8
3vector ÿÿÿÿÿÿÿÿÿ*fixed_size_list:double:7688j
lance0.17.0z
lance0.1z   Î Æ*m
0 ÿÿÿÿÿÿÿÿÿ*struct

null_count*int648
	min_value*string8
	max_value*string8 HA         LANC