## Setting Up the Indexer  In this BAYC indexing project, our main goal is to set up the indexer to only collect information from one smart contract: `0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D`, the [BAYC contract](https://etherscan.io/address/0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D).  The BAYC contract builds on [OpenZeppelin's ERC721](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol) with special BAYC features. You can find the contract's source code on [Etherscan](https://etherscan.io/address/0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D#code) or [Github](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol) for easier reading.  <!-- @include: ../snippets/evm-quickstart-reference.md -->  ::: tip Note You can find the full and detailed code [here](https://github.com/subquery/ethereum-subql-starter/tree/main/Ethereum/ethereum-bayc) to see all the intricate details. :::  <!-- @include: ../snippets/evm-manifest-intro.md#level2 -->  You only need to set up one handler to index a specific type of log from this contract, which is the `OrderFulfilled` log. Update your manifest file to look like this:  ```ts import {   EthereumProject,   EthereumDatasourceKind,   EthereumHandlerKind, } from "@subql/types-ethereum";  const project: EthereumProject = {   specVersion: "1.0.0",   version: "0.0.1",   name: "ethereum-subql-starter",   description:     "This project can be use as a starting point for developing your new Ethereum SubQuery project",   runner: {     node: {       name: "@subql/node-ethereum",       version: ">=3.0.0",     },     query: {       name: "@subql/query",       version: "*",     },   },   schema: {     file: "./schema.graphql",   },   network: {     chainId: "1",     endpoint: ["https://eth.api.onfinality.io/public"],     dictionary: "https://gx.api.subquery.network/sq/subquery/eth-dictionary",   },   dataSources: [     {       kind: EthereumDatasourceKind.Runtime,       startBlock: 12287507,        options: {         abi: "bayc",         address: "0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D",       },       assets: new Map([["bayc", { file: "./abis/bayc.abi.json" }]]),       mapping: {         file: "./dist/index.js",         handlers: [           {             kind: EthereumHandlerKind.Call,             handler: "handleMint",             filter: {               function: "mintApe(uint256)",             },           },           {             kind: EthereumHandlerKind.Event,             handler: "handleTransfer",             filter: {               topics: [                 "Transfer(address indexed from, address indexed to, uint256 amount)",               ],             },           },         ],       },     },   ],   repository: "https://github.com/subquery/ethereum-subql-starter", };  export default project; ```  As evident in the manifest file, this project includes two handlers: firstly, a transaction handler responsible for capturing the `mintApe` function, and secondly, a log handler tasked with indexing the `Transfer` log.  <!-- @include: ../snippets/ethereum-manifest-note.md -->  <!-- @include: ../snippets/schema-intro.md#level2 -->  Now, let's think about what information we can get from this smart contract for later searching.  ```graphql type Transfer @entity {   id: ID!   from: String!   to: String!   tokenId: BigInt!   blockNumber: BigInt!   transactionHash: String!   timestamp: BigInt!   date: Date!   boredApe: BoredApe! }  type Mint @entity {   id: ID!   minter: String!   boredApe: BoredApe!   timestamp: BigInt!   date: Date! }  type BoredApe @entity {   id: ID!   creator: String!   currentOwner: String!   blockNumber: BigInt!   prorepties: Properties! }  type Properties @jsonField {   image: String   background: String   clothes: String   earring: String   eyes: String   fur: String   hat: String   mouth: String } ```  Three entities are derived from the handlers mentioned earlier: `BoredApes`, `Mint` (used to store data associated with BoredApe transaction creation), and `Transfers` of BoredApes. The Bored Ape entity features a `currentOwner`, which changes with each transfer, and it includes properties like metadata stored on IPFS. Clearly, these apes were initially created using a specific function and may have been transferred, and this project monitors both types of transaction entities. Both the `Transfer` and `Mint` entities are associated with a `BoredApe`, enabling retrieval of all transfers and the `Mint` entity within the Bored Ape entity.  <!-- @include: ../snippets/note-on-entity-relationships.md -->  <!-- @include: ../snippets/evm-codegen.md -->  ```ts import { Transfer, BoredApe, Properties, Mint } from "../types"; import { TransferLog } from "../types/abi-interfaces/BaycAbi"; import { MintApeTransaction } from "../types/abi-interfaces/BaycAbi"; ```  <!-- @include: ../snippets/schema-note.md -->  <!-- @include: ../snippets/mapping-intro.md#level2 -->  ::: tip Note For more information on mapping functions, please refer to our [Mappings](../../build/mapping/ethereum.md) documentation. :::  Writing mappings for this smart contract is a straightforward process. To provide better context, we've included this handler in a separate file `mappingHandlers.ts` within the `src/mappings` directory. Let's start by importing the necessary modules.  ```ts import { TransferLog } from "../types/abi-interfaces/BaycAbi"; import { Transfer, BoredApe, Properties, Mint } from "../types"; import { MintApeTransaction } from "../types/abi-interfaces/BaycAbi"; import fetch from "node-fetch"; import assert from "assert"; ```  `Transfer`, `BoredApe`, `Mint`, `Properties` and other models were created in a [previous step](#2-updating-graphql-schema-file). On the other hand, `OrderFulfilledLog` is a TypeScript model automatically generated by the SubQuery SDK to make it easier to work with events.  You may have noticed that we import the `fetch` function from the "node-fetch" library. This import is necessary for querying an HTTP gateway that retrieves data from IPFS. Since we're fetching data from external API endpoints, it's essential to launch the node with the `--unsafe` flag. For further details, please refer to the [documentation](https://academy.subquery.network/build/mapping/ethereum.html#third-party-library-support-the-sandbox).  As a recap of the setup procedure detailed in the [Manifest File](#1configuring-manifest-file), it's important to note that this project includes two handlers: `handleMint` and `handleTransfer`. In the provided example, we've established a connection between these handlers. Now, let's examine the end code:  ```ts async function getOrCreateApe(event: TransferLog): Promise<BoredApe> {   assert(event.args);   let boredApe = await BoredApe.get(event.args.tokenId.toString());    if (boredApe == undefined) {     const ipfshash = "QmeSjSinHpPnmXmspMjwiXyN6zS4E9zccariGR3jxcaWtq";     let tokenURI = "/" + event.args.tokenId.toString();     let fullURI = ipfshash + tokenURI;      let content = await (await fetch("https://ipfs.io/ipfs/" + fullURI)).json();      const properties: Properties = {};      if (content) {       properties.image = content.image;       let attributes = content.attributes;       if (attributes) {         for (const attribute of attributes) {           let trait_type = attribute.trait_type;           let value_type = attribute.value;            let trait: string;           let value: string;            if (trait_type && value_type) {             trait = trait_type.toString();             value = value_type.toString();              if (trait && value) {               if (trait == "Background") {                 properties.background = value;               }                if (trait == "Clothes") {                 properties.clothes = value;               }                if (trait == "Earring") {                 properties.earring = value;               }                if (trait == "Eyes") {                 properties.eyes = value;               }                if (trait == "Fur") {                 properties.fur = value;               }                if (trait == "Hat") {                 properties.hat = value;               }                if (trait == "Mouth") {                 properties.mouth = value;               }             }           }         }       }     }      boredApe = BoredApe.create({       id: event.args.tokenId.toString(),       creator: event.args.to,       currentOwner: event.args.to,       blockNumber: BigInt(event.blockNumber),       prorepties: properties,     });   }    boredApe.save();   return boredApe; }  export async function handleMint(   transaction: MintApeTransaction, ): Promise<void> {   assert(transaction.logs);   let transferLog: TransferLog = transaction.logs.find(     (e) =>       e.topics[0] ===       "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",   ) as TransferLog;   let boredApe = await getOrCreateApe(transferLog);   let mint = Mint.create({     id: transaction.hash.toString(),     minter: transaction.from.toString(),     boredApeId: boredApe.id,     timestamp: transaction.blockTimestamp,     date: new Date(Number(transaction.blockTimestamp)),   });   mint.save(); }  export async function handleTransfer(event: TransferLog): Promise<void> {   assert(event.args);   let boredApe = await getOrCreateApe(event);    let transfer = Transfer.create({     id: event.transactionHash + event.logIndex,     from: event.args.from,     to: event.args.to,     tokenId: event.args.tokenId.toBigInt(),     blockNumber: BigInt(event.blockNumber),     transactionHash: event.transactionHash,     timestamp: event.transaction.blockTimestamp,     date: new Date(Number(event.transaction.blockTimestamp)),     boredApeId: boredApe.id,   });   transfer.save();    boredApe.currentOwner = event.args.to;   boredApe.blockNumber = BigInt(event.blockNumber);   boredApe.save(); } ```  This code snippet demonstrates `handleMint` that is handling the minting of new Bored Apes. Firstly, it asserts that `transaction.logs` exists, then it finds a specific type of log within the transaction logs (based on a topic hash) that represents a token transfer. Later it calls `getOrCreateApe` to create or retrieve the associated `BoredApe`. Finally, creates a `Mint` object with information about the minting transaction and saves it.  The second handler is `handleTransfer`, which processes transfers of Bored Apes between users. It takes a `TransferLog` object as an argument, asserts that `event.args` exists; calls `getOrCreateApe` to create or retrieve the associated `BoredApe`; creates a `Transfer` object with information about the transfer event and saves it. Lastly, it updates the `currentOwner` and `blockNumber` properties of the `BoredApe` object and saves it.  Both handlers use `getOrCreateApe` function. It attempts to retrieve a `BoredApe` object from some data source using the token ID obtained from `event.args`. If the `BoredApe` does not exist, it proceeds to create it. Apart from the data obtained from the logs it fetches additional information from an IPFS, such as image and attributes, and populates a `properties` object. Finally, it saves the `BoredApe` object and returns it.  ğŸ‰ At this stage, we have successfully incorporated all the desired entities that can be retrieved from BAYC smart contracts. For each of these entities, we've a single mapping handler to structure and store the data in a queryable format.  ::: tip Note Check the final code repository [here](https://github.com/subquery/ethereum-subql-starter/tree/main/Ethereum/ethereum-bayc) to observe the integration of all previously mentioned configurations into a unified codebase. :::  <!-- @include: ../snippets/ethereum-mapping-note.md -->  <!-- @include: ../snippets/build.md -->  <!-- @include: ../snippets/run-locally.md -->  <!-- @include: ../snippets/query-intro.md -->  ```graphql query {   boredApes{     nodes {       id       from       to       tokenId       blockNumber       transactionHash       timestamp       mints {         nodes {           id           minter           timestamp           date         }       }       transfers {         nodes {           id           timestamp           date           from           to           transactionHash         }       }     } } ```  <!-- @include: ../snippets/whats-next.md -->         ‡0      °F}_JÇŠ?èN°ÿ:7¢¿2R1Æn<Å¿.Óxç%œ¿1<YŞs²?[hä||‘?jÌ+¤êÁ¢¿­,?ôÍ¡?¢_˜¢E¿VMIûƒf^¿Ó‡ÆÄúÇ—¿ú}ÿæÅ‰¶?lÕ	ÃÛŞ°?M1Ï–è6u¿0+Ììƒ]?×æµÈ,1§¿6JU«¿¸+Ş4“¿(ækàXq?FslVàØ­?güÜM€¿É·y%ƒ¿Ôê/ä¦@m¿çã
ŠG+„?4Hâa±¸Ê?ÚõBi¾«?n)êCLÆ­?;£sŸ˜Ì¬?¾¾÷³/²¿<oéìòŒ¿¼¡¾Ÿù ? V–Ì,k?cw! ÖP‘¿Ä3ş U¿$DÅ@2:?áª™RêÔm¿*…IÄŞCf¿çjö;r‚?)Ï^_æ…?Xà“jl¤¿®ŒµÛmt?”´şŸ£¿øÃƒñÉFd?óÂàõ‚w¿ét?g¾¢?ÙŸEhd“?Qìp2¢?o–e·š?.l&¦?¦Qb†¯w‘¿M`¬iÏ?Ş„ù-e?`.Í æS‘?:èñÿÓ"±¿+},Q·?v±·4™Œ?mÿÙØi“?IF1íY›?-PP_Ö‘q¿'ÉpÅw¿*AÃ¾DŒ ?O-7%³’?|ªØÒ‚›™¿Š±†jÎê ?qÁC Tåm?"«ølT¢¿7Ş_5}Š¿ÛÍ!ã0¨?nø´>Y?Ì¼”;å1p¿Äoíé­?93K§‚?r´6Ï	ˆ¤?4õÄ·Ó}–?KCÇíš¿`3	y€¿‹Œ0{Ğ)l¿zdHÿ(¿|zlË€c?\2uôKp?k>D)uW‡?XÇR4~?ÛÒr¹${µ?Ovñ†MÇ?dÑƒ¡_r¡?kE9ÅÉ?³Nì@uI?q™Ëôè™¦¿½3ñ±`¥¿‹L¶=S›?r‡"ä‰r¿[Òóœd¢?ûŸÓ^
0´?›ö¸b‹L¥?`bTş´¿­Õ+ E–¿@B*KÈ•‹?Üõ£Fe¨?$S­¡®—­¿:XF½¼©¿®g«n¿¥a¾İä?`PKr¦?Õ³Şw%,³¿Y¿W|\°?x",—?;$Jµ.¹ ¿’í×ø§¯˜?áN;_`€¿„O;HÄ–¿i"Ç1íö®¿ÂAA¨Ù¨?8âÎnõŒ?5İŒ`¤¿Ô$iíÚ’¿¡dc?:^§¿TŠ>›, –?á9c±°T¯¿“£š>­›?ï #Š¢?ü³¸Ù«¿–$] ••“¿·£Èëâz?:wızlh³?ÊÂj;ŒšŠ¿•Å ¸•?¥íƒ²é§¿ƒ¾gqe??Îå'¿ËQU_gr?³@ÜQs$°?DsøÿÌ{›¿ñèÜs´€¿°×ÛqÁ\M?PwEÀ†¡?<¨ş Z²?û Xî¿yr°«‡7¨¿ Ç tš?”Œ¨AûN`?ö‹‹å?“?ìF¿€Õr?Ÿ3š>š?W…3ã`{ª¿ùwè°¿İ$°€ÜZ ¿&¡°‚?DÒvez6°¿_&Ÿœ¿¶†ÄĞù†?Ä8Œ=‘¤?$Æ|Š-N¬?*XŠhd‰¿Ó³K2¦?u Ê›ì±?	ìãb› ¿_Äã¯„š?qp{ô‘?ŒqFMßÓ?]¿|Œ›?Yjk#"«?Ë\ç>|t?}²AªQİ®¿E´á”–?D¡ÍÀ´ç“¿Å¾*88è­¿'¯×ã?"#wCài¥?áì÷@£?éØ Å@°?Ÿ	‡½Ôø¨¿Sö+×ºX§¿yº7âp¶ ¿¥©kÛšîŸ¿Ş§BB,–?3Ó µŸ¿¦âxuµ?‚ñÂŒßÊˆ¿.áéAüh?–6T@e‚¿U†ßøÛt?JiËó¿à£¿¾Q}ôA¥?—î…4ğÄ¤?ä‡8@ª®¿Æ¨ÍQ¢¿ı8q¤ù„¨?…P1üVˆ¿³¾¤Ø¡ÿ¿¥É9ok$¢¿j²j¼to¿¼^Àébui?æÉÌŞ†¿!®Kv4ZS?Å¦ølÛÿ­¿mºÚ~âûA?ã";’rÇˆ?.†–hÕV’?°^Ë®?QpëM¨¿j…m´±L‚?¸<b˜ ¿›ñqş
¿²¿#?”È;„¿AÃmıŒ¼«¿âp(tEÆ¢?(Êô7àd¿­‹r`fUx?œ%)28~¿âæ^Wª?l=Çp
e±?˜"m¡3‚ ¿Wİ€UI˜¿üòÁsvt?Åš4‡P”?”0;Ú$~Š¿ï3‚–÷¿N˜Q¨~³¿sÂ|`dU¬¿SÙ‡'î•?Ï8r|kb¤?²c¬à˜?ù ºV1K¯¿ó3—ÈÃ¨¿´#|¿6º§?w(Œ¼œ?}ÛÏ¹‹?Š	ƒ•·áŸ¿%S†N#Ÿ¿èZ|˜*—?¤“F@ÕER?WË Ä¡³¿%Ë\	r©?X.ÒÆ<ë™?ÈrÜ›rŒ?İ·Ä¡?`—<ùO‚¿ıÉ1¼;§?ùHÅv,¿’|ÆÊ×•?<´	Ü,ñ¯??%7}š?¾ë;ØÅá’?WßQGíœ“¿\-â†a¬¿ôüRÅ‹¿Lif¥§¿ßå\i™¿£ÆO¦{ä‰?¿+‚ÿ­ä³?ÖsÜm:©‡?ï(„Ä,j ¿À¥\rÀ ?ÇT`Á+ ?`˜D¤C3™?“rµl¤¿¨R³Z•¿¡Ôâ|½ ?©˜1¢@á„¿~›rC[ç«¿«ôWë[?A@íáùz¿’¥®3À0‰?ONgÎÊŸ¿Å‹Uè[˜¿]#Õ¹š#œ¿­ÎŞ×Pƒˆ¿0h"&Èo¿m´Ù:w¿êödÂ¤¿|ñ@Â(ª¿7ó’œŸ$¡??Ãş_3È‚?êz?Á§´?_çÙ¾İ~¿=9)Ã›—¿Û¼A‚šœ?88K¨d)™?<4Äbè™¤¿>Da¶W“?°ÀcyÈ]?ˆ—!:vãŒ¿	gß„^ƒ¿¸üüS)¿şC?y-ßa?C=‘èä“Ÿ?¸Ê½‚Ü–?”¢N¦õª†?°€¶“‘?~z#c‹x¿íh
¼x‘?íàâGë‚? (Vx]à¦¿Pôô×”?>ÁÃ‰ï?'à¥|’À}¿T
O"¡±¦?tfCØ¢?‡ìßœák£?¶ZgIn·Š¿ #ó¾­˜–?aZò}8?=­Ë¾e­·?Mõ·Ò·Q?$²Ü.˜?Bá9=³¿»å«cãa”?ŞîkxP„¿’…}u4’§?u.Cìy?¬àEvİ¿Üá¼\Œ›?, Øä5”¿¦D€²?ş}¢Õf´¿iÏÀ#…˜?í¬Ñ.¡?ü×T>M+v¿<Y’…?D¢kï›¿+ğE_°`¿–Š:””¿ø€à ?ü¬A~‡¹˜¿îQêXÆš¿—×Q¢¬?nÀj½`¿×MEÅŠ¤?~ÇX¼D4‹¿.qwå™èŠ¿¯—dì4‰¿dpè»Èõ¢?ˆÑËØM¿â©ÇÁ ¿”-b=2}?B½Ï§Dµ?ç™RïG‹?èYÿ£D¿xÖ™;-Q‘¿Ø†£Ÿ2ª?\—İ=‡Ì¦?’OÕfŸ¬`?Ià»?qª?_w€Ü²¿½-DÆ$¦?GñMz¯¿t¿©ıRğø—¿ºòW÷¿~Ìb½¬ä”?+/T¢{¿‚F])Ó°¿xaâÄ”‚?õDá@²Cw¿ïÃëAÛF£¿¥UÂM%‡?ëX^Á€¿.ÓåƒT@±?^"V¦€¿g bu“¿-_UÅm—š¿µù6¯©?^—:ø$Ø¿ÆZÕ—?7&Æ]}o‰?{ÂÖƒ›?ßÿCÑnš?J]#cd²¤?¢Â9l 2Œ?=©Ä¯7µª?+ ;ú„@?Ÿ·A…Ô•¿brœ|7tS?AÀM‹¡?Vï‚ğš¿Ë/ú?Ä\¡?94©ÄÔ•¿½µùÈœ·¿D@š¾’<‡¿”c”b¥T§¿ˆô±|JÇ=¿ÚÆ;œÍ«?2Ô^ÍÌ£¿TbŞ°[n¿ÅÚ –¤?õx}y½g?ßèÍ"À[‹¿±ò`¡?!=‘œVNf?°|®_=¡|?b7ûá±¨R¿\Ğüãİ•¿Ğ…Õ{Ñî—?z'{Xca˜¿óÇ“(¤Ê”?¥‹­±ú¥¿‹ÓZâ‘¡¿Æ"ˆñ^§?Í!ÓàÉub?é®Óå *‘¿Û²~¼" ?N«]Dš¿$¼˜ÁsÊµ¿Ä0³€f¥?úWş¢¾M¿êe…Œ?¾¾«%êós?vÄuÓŒ?I|bÃñ¨¿é´H¼7ä‰?™“¶/]g?ÔLRôƒ?xmÂÿNA®?ØÆ‰ÃZûŸ¿NsÃ8}˜¿I‰Æpû‘¿úká’?~?ZöÁ…~°?¡x QQqŸ¿-—·Kd”¿Ù½Š4$x¿5#½;A‘?Äs[Ç])°?ÁÎü×ªv?êC›Ã<‚W?­>¢{z?˜gÏ¬?Š?*‰_Dê†¿ó^‚A< ?Ñ¶KÄw€?™},Ti²¿ÿLaS¯‘¿Üğ¿"Ì€¿¾ì/ŸÒß¡?í	°°ÉŠ¿­qEH.†?{Şã>*‘?Ç(®Áˆ¿Tr.Ş¢|?P_n£?<q&–E?âªŒ¹ ?{^şş%•¿òcŠAy‚“¿&`vzr?^%¸öİ™?ºŠ )}´?	Y£?°²? pU]°é™¿~,„¢g©¿ê²“Ãó’¿ÙP¿Ë§•?=·ªÎeÈ‡?º|Cç‘l?%‹TH”ƒ?ûšİA‰"µ?”»zf?–€üÿåF¿XqËÃ¢?Û¼õŠ<ƒ¡?Ä/Úz}b?e±eRsš?É	™‚ø‘?·‘6~vú«¿µDS# Ùz?kÇ‰=Ø~¿üàøAÈ‘¿=Š. q}~?Åbió¢¿s&²A±?&«@ï™?ud§F¯¿jca’2Œ?’y|,‘£?ÿ×•£»|—¿~
1«8T†¿£{”ˆÈ?ı®¹·ãÌ™¿u§ºÎ&Š¿®Y¸z?c¿‘°QÑ¶l…¿¼ÃF‰ø¯?ŒÊÂ××˜¿sd£{±¿MÁ<ºÊ§¿vğ êü›¿Aãß®1Œ?pH–Ø$[‹?‹òÏƒğ¥¥?hZƒs£?ëÑ+Ğ´å ?nfRã”z¿s–aõªB?ÀLgiŸu ?Àb´^q[?qDÄ»Æ¨­?D¹go†¡y¿~Ã‹X ê¿Ìu “M¨?ÑYØfrP‘?X{Ù*{?kWyæp?5û£ ¡?O6…˜Â¸˜¿Ûzù¡ºÇ^?ÿ @UR­? ‡DdKäH¿øc]SU ¿]ÆÄÖª©¿e¸*Q ³¿dY|h ¿¢~Ö¾¹-p¿±£ÿR÷â‚?¯^İb’R§?>|áûR ?ìÍ!Ûª?øüÍ¦¿›´9fŠM˜?Çg.Gúz©¿RÓ›BÈ(¦¿C˜\>ò•?•ğÀœr§y?ãídÜt¿ pkdÓ•¿ j‘£ï$¥¿Ùø_î`¤¿>ñÑª¶è¿`0¡,
˜?®]r7±¿óéIJüx¿ĞáÎCuŒ~?×”Óºç¢”?Õ]a‚Y¿İG†ĞŠm?_,l ’¥¿-‚Š í¿›åÓß"b¨¿²U‰Æï™¿%7³+gÎ ¿3g¹‘‘¿‰$›'®•°?Éi@™S¡?·=Åš_“¿~R¡E¬–¿ åg»¿Ø4ñ9p¿h`?À}¥¿Z/ed¹:ª¿Ó‘„Æ@…¿ê8:‹7b„¿ãçpÁÚ—®¿ÜódM‡? ëóÿGy´¿NÙDÁçâ”?IŸVQ±¿8l¶MLrs¿üƒqN•{¿õ')dr`›¿ÿ>’{‚›¿‚Œ%QÔ>¬¿±¸È¨¿.IhBÈ¶¬?0BÑl¹[?c¿İH•š?€=Æßm¿½²Jjtƒ?Z—àõ{°¿¯ãÑ#ÌŸ¿µNàÆû«?Å d„Ò`?’m’cX§?Ïà‘¦±%j?ˆóOôéF¶¿ÒN&NÚ…¿ ‡&(üTp¿İNÅ"ıi¿,<y¢5Pr?İåqèx’¿GPvß£‘~?)	&ŠÒ˜¿ÖN€ ]ª¿`lÇ-?
¶¶•âš¿¾/3#ô‡?7ßûİw¿Œ3DoU´¿~ÉcYr?–1ş°·*‡¿Üf	¶:±¿uJ´¢Õâ©?Q¤Hî¿ÔĞ…ßíD–?—\FcMb?î¤Ÿ/lƒ¿ŠÇÉí,´¢? x‰B¯e§?"ß^ÿ™4†?>ÉP'6¥–¿Êû }˜ü¦?Ó©î;Íœ¢¿t-”+@œ¿£±@¼±Îo?A×¾€^¸?QÇ[•áË°?·±fİPY?Q‹§â)€?òÈo›ë¢?Ûo·ä4de?B* H9óv?Ía1ÉL’ˆ¿üŞ¸"·z’¿HÛZ"¼š?|>»]Ş˜?^#hlé¥¿ ìûª;š›¿œÀ¾ˆ‹?/NÀ#èµ¿š?¡ü¯´?6ÇƒÅ’¢¿¬-D ]2 ¿M‚İ®õ ¿†YrY¨Ü¿«ÂÌbUÉ¨¿3ü†?Í¡?ÁlaúY®¿ˆŸÿ¼v¡?µ¹UÙZ¨¿0¶ã‹¯¿Ë£*Œ~KŒ¿™¼àWÕ`€?‰ö¼gµ’?Ğ¤‡€Çà¨¿ ™õœÓ°?•Î,®–à·¿[Ç])pW¦¿z÷*¦3°¿˜Ef3)¿ª³ µ[£¿-f¾b‘O¦?N{­øD¦™¿iß[ß'?Å<[¢Û”®?mËÑú“¬Š?Éğ=8J¿ë›ï8)ò†?pX¿>ß§?:°Bè¥¿¦ª'ÈŠ?|Ë®Gr‹?'şßíN¥?VµÎ×4¦¿  @g5Ñ°?É&!Ó¥?«œÙ»›]?[üJ@|û¡¿s½P¶š¿)ÛHa¿?3S3•?'q)j¨¿eÏ30Ñ¤¿Dä X½r?Ô5áş&‹˜¿§çˆ¹š¿\I]øâ’¿`İò=•f”?E…‚n¤?5?Œ}º› ¿¹–Yš?NóG~èu¡¿ï]U†	T›¿áğŒúG†–¿H>|‡E†Ÿ?¾•ºÇ¬¡?änİ»pa…¿ü‰á"«æ¯¿„*˜¥[~§¿‹ŒHÂ¾­?I£<Òdï¬?…ü}¤?*Ì÷cÅ6?AÆÿÄ˜Y‡¿¾âq»g›¿ëH[€©«‚?_ÿ,˜#$?$íˆ;ÅG§¿ÂÓ2?¦?ÓÚ—à’ë¨¿­mi¹\’—?ôP¿1"V‰¿ƒ\Üt¬¿eáN–Ó°¿TóùÛu•?Ëwe!~!¥¿;@Ó­‘?=¨T!ÏB‡¿ìi²?ƒ_†¿¿•$ƒg8}¿75!ÄÍ]š?ÉAï'ˆÕF?š¢.âÓM¤¿E_»`â"?ã‘Œ]!ú‰¿f›2o‰çr?·²0ƒ²¢†?ïãË¸ge°?~Æ"Ùeğ±¿4 Pâ¢¿Œ!İ(âƒ¿î¬! .¦¿Ú¸ßPáš¿pANIêÅ‹?&•ßX‹“¿Åü:B–™?WïøÂ‹¿P‹æ¨s?Ñ<ÿhª?ë¥?yìs?ç5——ÓĞœ¿qØÂ›QÍ­¿M<?C:g€?ÖrA_uB¤?a ,ûü—š¿G"ZI0w{?p ä!ßç­¿Õ»¿ß¤¿yN'—Î €¿®€¹Kq¿$íƒ‚ß¡?èõà.eª¿jš+ª?ÏË¼¥¿|›IVhYL¿ÔŒm›§”?º1BCpœ¿$,ü&£?²áúu|•?²›†™—r™¿^§ËAT
¬¿3‹ÂÁíO¿,£^Ş† ¿Kv!m¤{?òùm÷ô‹¿Ía£55™?8`Hhzr?aP	üŸË²?`ë WtpS?½—‹kW…?X>´Wk¿¾\#J?íÁœ‡°m¥?>·ÀA"‘¿Icrø?)7^uu“¿lSâ’Y|?)¦İR£?~izI¥¿—PÉ¡¿V¯ ¢Ø× ¿C-ÿ`?Zø4!I³?Ub\?¹°\ÙI’?¸½˜¾»» ?\nªš’?‘?CşÛ]N”?Ê-™¢İšŒ¿Áñç¡×d¿	G ŸnŒ¯¿ªRÑ]´õ•?‡0             —0                     ## Setting Up the Indexer  In this BAYC indexing project, our ma¿H      ÿH      ## Setting Up the Indexer  In this BAYC indexing project, our mbI      OI                      ·H             ÿH             OI             v   
content ÿÿÿÿÿÿÿÿÿ*string8
3vector ÿÿÿÿÿÿÿÿÿ*fixed_size_list:double:7688j
lance0.17.0z
lance0.1{   Ÿ“ —‘*m
0 ÿÿÿÿÿÿÿÿÿ*struct

null_count*int648
	min_value*string8
	max_value*string8 ß’J         LANC