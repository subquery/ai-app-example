## Setting Up the Indexer  In this Seaport indexing project, our main goal is to set up the indexer to only collect information from one smart contract: `0x00000000006c3852cbef3e08e8df289169ede581`, the [SeaportExchange contract](https://etherscan.io/address/0x00000000006c3852cbef3e08e8df289169ede581).  For a more comprehensive understanding of how these fundamental protocol mechanisms operate, you can consult the official [Seaport documentation](https://docs.opensea.io/reference/seaport-overview).  <!-- @include: ../snippets/gravatar-note.md -->  <!-- @include: ../snippets/evm-quickstart-reference.md -->  For instance, you can locate the ABI for the main Seaport smart contract at the bottom of [this page](https://etherscan.io/address/0x00000000006c3852cbef3e08e8df289169ede581#code). Additionally, you can kickstart your project by using the EVM Scaffolding approach (detailed [here](../quickstart.md#evm-project-scaffolding)). You'll find all the relevant events to be scaffolded in the documentation for each type of smart contract.  ::: tip Note The code snippets provided further have been simplified for clarity. You can find the full and detailed code [here](https://github.com/subquery/ethereum-subql-starter/tree/main/Ethereum/ethereum-opensea) to see all the intricate details. :::  <!-- @include: ../snippets/evm-manifest-intro.md#level4 -->  You only need to set up one handler to index a specific type of log from this contract, which is the `OrderFulfilled` log. Update your manifest file to look like this:  ```ts {   dataSources: [     {       kind: EthereumDatasourceKind.Runtime,       startBlock: 14946474,        options: {         // Must be a key of assets         abi: "SeaportExchange",         address: "0x00000000006c3852cbef3e08e8df289169ede581",       },       assets: new Map([         ["SeaportExchange", { file: "./abis/SeaportExchange.abi.json" }],         ["ERC165", { file: "./abis/ERC165.json" }],         ["NftMetadata", { file: "./abis/NftMetadata.json" }],       ]),       mapping: {         file: "./dist/index.js",         handlers: [           {             kind: EthereumHandlerKind.Event,             handler: "handleOrderFulfilled",             filter: {               topics: [                 "OrderFulfilled(bytes32,address,address,address,(uint8,address,uint256,uint256)[],(uint8,address,uint256,uint256,address)[])\n",               ],             },           },         ],       },     },   ], } ```  <!-- @include: ../snippets/ethereum-manifest-note.md -->  <!-- @include: ../snippets/schema-intro.md#level4 -->  Now, let's think about what information we can get from this smart contract for later searching.  ```graphql type Marketplace @entity {   " Smart contract address of the protocol's main contract (Factory, Registry, etc) "   id: ID!   " Number of collections listed on the marketplace. "   collectionCount: Int!   ...   " Sum of marketplaceRevenueETH and creatorRevenueETH. "   totalRevenueETH: Float!   " Cumulative unique traders "   cumulativeUniqueTraders: Int! }  type Collection @entity {   " Contract address. "   id: ID!   " Collection name, mirrored from the smart contract. Leave null if not available. "   name: String   " Collection symbol, mirrored from the smart contract. Leave null if not available. "   symbol: String   ...   " Buyer count. "   buyerCount: Int!   " Seller count. "   sellerCount: Int!   " Trades of the collection. "   trades: [Trade!]! @derivedFrom(field: "collection") }  " Trades exist such as a combination of taker/order and bid/ask. " type Trade @entity {   " { Transaction hash }-{ Log index }-{ (optional) ID within bundle } "   id: ID!   " Event transaction hash. "   transactionHash: String!   ...   " Collection involved "   collection: Collection!   " Stretegy that the trade is executed. "   strategy: SaleStrategy!   " Seller account address "   seller: String! }  type MarketplaceDailySnapshot @entity {   " { Contract address }-{# of days since Unix epoch time} "   id: ID!   " The marketplace that this snapshot belongs to. "   marketplace: Marketplace!   ...   " Number of traded collections of the day "   dailyTradedCollectionCount: Int!   " Number of traded items of the day "   dailyTradedItemCount: Int! }  type CollectionDailySnapshot @entity {   " { Contract address }-{# of days since epoch unix time } "   id: ID!   " The collection that this snapshot belongs to. "   collection: Collection!   " Block number where the snapshot is taken. "   blockNumber: BigInt!   ...   " Number of traded items of the day "   dailyTradedItemCount: Int! }  " A helper entity that maps a trade's order fulfillment method" type _OrderFulfillment @entity {   id: ID!   " The trade being fulfilled"   trade: Trade!   " The order filfillment method"   orderFulfillmentMethod: String }  " A helper utility entity that works as a set for deduplication purpose. " type _Item @entity {   id: ID! } ```  From the single log we're working with, there's a wealth of information to extract. Notably, there's the `Trade` entity, which signifies the buying and selling activities within a protocol. This entity, as shown in the schema, serves as a link to other entities like `Collection` and `SaleStrategy`. Furthermore, we've included statistical entities, such as `CollectionDailySnapshot` and `MarketplaceDailySnapshot`, to streamline the overall analysis of the protocol's economic dynamics.  <!-- @include: ../snippets/note-on-entity-relationships.md -->  <!-- @include: ../snippets/evm-codegen.md -->  ```ts // Import entity types generated from the GraphQL schema import {   Collection,   CollectionDailySnapshot,   Marketplace,   MarketplaceDailySnapshot,   _OrderFulfillment,   Trade,   _Item,   _OrderFulfillmentMethod,   NftStandard, } from "../types"; import { OrderFulfilledLog } from "../types/abi-interfaces/SeaportExchangeAbi"; ```  <!-- @include: ../snippets/mapping-intro.md#level4 -->  <!-- @include: ../snippets/ethereum-mapping-note.md -->  Writing mappings for this smart contract is a straightforward process. To provide better context, we've included this handler in a separate file `mapping.ts` within the `src/mappings` directory. Let's start by importing the necessary modules.  ```ts import { OrderFulfilledLog } from "../types/abi-interfaces/SeaportExchangeAbi"; import {   Collection,   CollectionDailySnapshot,   Marketplace,   MarketplaceDailySnapshot,   _OrderFulfillment,   Trade,   _Item,   _OrderFulfillmentMethod,   NftStandard, } from "../types"; import {   SpentItemStructOutput,   ReceivedItemStructOutput, } from "../types/contracts/SeaportExchange"; import { ERC165__factory } from "../types/contracts/factories/ERC165__factory"; ```  `Trade`, `Collection` and other models were created in a [previous step](#2-updating-graphql-schema-file). On the other hand, `OrderFulfilledLog` is a TypeScript model automatically generated by the SubQuery SDK to make it easier to work with events.  As a reminder from the configuration step outlined in the [Manifest File](#1configuring-manifest-file), we have a single handler called `handleOrderFulfilled`. In the context of Seaport indexing, the following code segment illustrates how trade events are handled:  ```ts export async function handleOrderFulfilled(   event: OrderFulfilledLog, ): Promise<void> {   // Assert event parameters   assert(event.args);    // Extract relevant event data   const offerer = event.args.offerer;   const recipient = event.args.recipient;   const offer = event.args.offer;   const consideration = event.args.consideration;    // Attempt to retrieve trade details   const saleResult = tryGetSale(     event,     offerer,     recipient,     offer,     consideration,   );   if (!saleResult) {     return;   }    // Calculate trade-related values   const isBundle = saleResult.nfts.tokenIds.length > 1;   const collectionAddr = saleResult.nfts.collection.toString();   const collection = await getOrCreateCollection(collectionAddr);   const buyer = saleResult.buyer.toString();   const seller = saleResult.seller.toString();   const royaltyFee =     (saleResult.fees.creatorRevenue / saleResult.money.amount) *     BIGDECIMAL_HUNDRED;   const totalNftAmount = saleResult.nfts.amounts.reduce(     (acc, curr) => acc + BigInt(curr.toString()),     BIGINT_ZERO,   );   const volumeETH = saleResult.money.amount / MANTISSA_FACTOR;   const priceETH = volumeETH / Number(totalNftAmount);    // Process each trade within the event   const nNewTrade = saleResult.nfts.tokenIds.length;   for (let i = 0; i < nNewTrade; i++) {     const tradeID = isBundle       ? event.transaction.hash           .toString()           .concat("-")           .concat(event.logIndex.toString())           .concat("-")           .concat(i.toString())       : event.transaction.hash           .toString()           .concat("-")           .concat(event.logIndex.toString());      // Create a 'Trade' entity for each trade     const trade = Trade.create({       // ... Trade details ...     });     trade.save();      // Save trade fulfillment details     const orderFulfillment = _OrderFulfillment.create({       // ... Order fulfillment details ...     });     orderFulfillment.save();   }    // Update collection and marketplace entities   collection.tradeCount += nNewTrade;   collection.royaltyFee = royaltyFee;    // ... (Additional collection and marketplace updates) ...    // Prepare for updating daily traded item counts   let newDailyTradedItem = 0;   for (let i = 0; i < nNewTrade; i++) {     // ... Create and save daily traded item entities ...     newDailyTradedItem++;   }    // Take collection and marketplace snapshots   const collectionSnapshot = await getOrCreateCollectionDailySnapshot(     collectionAddr,     event.block.timestamp,   );    // ... (Additional snapshot updates) ...    const marketplaceSnapshot = await getOrCreateMarketplaceDailySnapshot(     event.block.timestamp,   );    // ... (Additional snapshot updates) ... } ```  This code snippet demonstrates how trade events within the Seaport marketplace are processed and indexed. It covers data extraction, calculation, entity creation, and updates to both collection and marketplace entities. This indexing process is essential for tracking and analyzing trade activity within the Seaport protocol.  ğŸ‰ At this stage, we have successfully incorporated all the desired entities that can be retrieved from Seaport smart contracts. For each of these entities, we've a single mapping handler to structure and store the data in a queryable format.  ::: tip Note Check the final code repository [here](https://github.com/subquery/ethereum-subql-starter/tree/main/Ethereum/ethereum-opensea) to observe the integration of all previously mentioned configurations into a unified codebase. :::  <!-- @include: ../snippets/build.md -->  <!-- @include: ../snippets/run-locally.md -->  <!-- @include: ../snippets/query-intro.md -->  ::: details Trades         ¤*      ¾a–Ç†?¨Ÿ¿N¼¢¿#®[Î¿(ŞÀì·¢¿âÎ™uEw`¿[òùÚ“½–?ºÿtuZÆt?‹Şæã“{¨?HYEÓgtx?<»Ás–“?¹½o?Š¡?V‚æïµÒ•?îŸŸÜ˜¤?Èx_X¨|˜?¼ÆM­|¿ ‡Q¨XI¿ÅVö{g‚?Ô¤Êæ`ì­¿IêyAˆ‡«?	ıÚg†n}?ÁØJÌ©²?¤İ*€f©¿±”³Ô.“?â^ôp]Œ˜¿µL+*‡;Ê?tÛ¶Ö´Ş‰¿	æHd¨U¢¿uÏe"w¿.Z9áIş¡¿ÕÉNG«¿©dÁCŸ/œ?…º¡åd¡¿ÖYØôŒ?ûm™óKz¿Måa_ºb‡¿ìôÊÔ?°Â¬3l‡¿ov"ÃU^“?ŞùN›?nş$\üW¿¹ÁlÜD(”¿ıwG)•°?VÙ|ş©(²¿á<Å?¦”£?6Gëâ¬? Â~@¢¿´§G7–?Ÿ©``W¡¿›¢´£“¦?!Š3mœŒ?<Zd¬Ab?f1#O¡q?ï¤‰r«¿á"¡t¼©¿"Ô˜R¯?V/abc†¿+JF$ÃW­?^R£úHö?kÇy€‘?fâıˆÄÜ|?êİ°QüŠ?|fX«•?Şœ´ê¶‡¿ÖCÉ€X®?——‡B‡¤?‰àêÆÜ§¿!v¡À$‰¿¨h´næ›?Ã ²$?Ì-J\	Õ ¿da_dŸ?”ûÛm07¦¿–³é›C8£?l—²ãñz§?\\…Â×›?Ê(ü=¤$¤¿\re{ ’¿pKj¼>?ĞK#¿±àë\2=¢?Ò”±b7º?$5Éœ"¬¿@d™—&³?®Wß`rª?ùó¿‚<?Qªtíxˆ?)äƒn¿½iNìs¿aîÅ^”?­Ëßs ?Şwqş?J™Ãb’©?€†P‘Ê–?~}>Ïg¦?Ú¸Q¦És³¿œû… Û¿k]éiÉ«¿à‡bv?<¥?:æ~1¨¿MªÏ8§¿²‚ •Ò”¿ÀñhOí•¿KÛlj¨j·?Ä‰f ]~˜?Óf ¿LN²?¸Ï÷A ê–¿àIÛ]?{š¿çÎówTÔ™?˜ºeüœ¿d‡¥?¨?!PV<£¿ßâŸ!5Ğµ?,EUÀû²¢?Up²ìÍ˜°¿V–g¬+¿·]®`{¿v)”Öö®u¿êCû~ˆª¿DÖ/œH?Ç1ÌèËû±¿À{¢F|‚‘¿½ü1x[s?géöÑ*¬Œ¿éŞÅ&òW’¿=Š. q}¢¿Œ‰Lş€îw?„ô  Ğ°¿l˜C€C?ºßÛÓYV¯?f®Âóğˆ¿\©Àùo†?¾iB°¥‘¿mA+Â ?hF»á©w¿0'ï:×‹c?5êñàÆä•?3Òv?³“¡¿h§ö)”?Òv¢İNF˜?ÔvÏ^Öô©?{¥Ä_§¬?«Ob¥¼5¿±ñhü%f¿âŸ;@5·i¿-9rÍ²aˆ¿túQ?5¬¿WìU‚Êš–?³X%¹E^™¿ç[HHoƒ¿«À´›%pª?Ü:îJ»²?8ùÊº?İâÈ fŠ¡?‹Mm¡t™?¾D™fê€?ºkk9ˆ¿[„€ÂÎˆ¿åóÄR¨—‰¿§%*QY™¿7ébE 	Ÿ¿xl™Fr}¢?>Ïğ}©S“?Bù¡#Ğ˜™¿L¥À~_°?j‘™}±”¿
z¹™«¿Mk²Êuè¨¿qlçB}ª?½Ú^Æ¥?¢2Õş”K¤?I)PÚ˜”¿»«û û?º_¼!¸Š–?•4VÍ£?I{¶ ñ±…? ¤ğØJ•?ô/Ctì¡?òåñó`‰¿l_dg©›?Å<È>
Ï¥¿²(k"Ó¤¤?• LôKš?{´@Ôà¤?x¥Ùúñ°ƒ?õ/Şlş??phZú¿¿¶²G(ô?š;Š°Å€?‹w}‡Ğ¯¿¯¶¸’&—¿J!éd¡?•øÔ˜­H¢¿ÇlT‘å“¿_ *úÑİ¿©nf_öÅ^¿Å6-¡P‰¬¿××P”?;o¥Ïõ†?cûûR`¤?á µ‰0Ñ±?ë‘ ¥?|–Jì˜Â²¿éNêªÄe±¿œ_F{¿òHc„U”…?ö0îåÂqª?]W½”"w¿Á^Ë¥‘¿‚ˆ_êİk¿¶†ïPV¢¿©–Å$¢/[?3¢ñš Š?­ŠT>"«ª¿y»|Ÿ¿DBCã¯ ?3A™§İ…¿Î3yƒ?_Õû»®Ç­¿C|yd ´¿óBBEÌu?¯x ïÙš?ä0+#¬¢?/5&ê#u?Wl•0AE¿Î–ö…LDc?ûrï¬ ?JO+az¶ ¿#U-LSÂ¡¿ÀB¤®Î”²¿³(ª†<‘?Â½ÀíÒ¿‡àvpÉÔ³¿¼TÊ=íˆ¥?ŸøÂHU1r?©¾È¶ÿƒ?éâiC‚¿Ö ™è¿9DD€¿×•¿ù5_<“¿ªåÜØºp?ª/ò‚íÿŠ?¿{öE
±‘?Ÿ8V#¨y?‰=ç€º–?(í²¾G ¿„.áĞ[<¦¿µü7d@LŸ¿—Ó…µù•¿±2‚Ü1´™?©W9Ğ¦Œ?Ñº(ãèıY?Oß!	†?·ÕŞu‘¿¯j_„£?BLÎf¼–?úrô¤¿É1ºöä¿BßµEW¤?4õRbëÚ?¶Ô³…÷«¿·˜À)ƒÕ³?œï¯7”N¨¿@¹Æ—ë•—?¿Xı-Û§¿ÂZ8?… ÒÒ«E?bÑ~™?ı¹Ëò3ı£¿·íqbìİ¥?÷æ8¨Ş™¿áq±¸³¿DGY\o¶?&Q/ø4'³?\Ê;Á¥?8°ÉØØ>‡?®i	òæ‚„¿Tv¦BÏux¿ƒ6ºüçf¢¿íØ€÷²z¿T¯t¡f›¿¥¬•¿1ºz?$É¸Q€‰¿ps2ŠHÁ?å3>W^?ÔÿO–¿aEåİ“²¡?`úâP”¡?Ş{ÑY_?X•æÿ–?`KA
 ¿…Fºãp?Y¹Á—\ ?İªøzOÉ¿H{
 à‘¿g&\Âú‹?ÆÓ <B£?»ÙÏA¸?Z‡¹Ù¥ªe¿ß0ãÁ7•?gæ°˜d&«¿EInkˆ…¿ÏJvF=?œ?>+ş)„?vœE¥¿˜¾`z‹†¿îã€‚?µ"½_3E?{M03ô«¿1üuáæØ ?!ÌO?âª?ö&‹K¤¿G	÷S®‡¿Ó$ãŞ•¿ajb¹YG?LN=]Íy¿É…e”°4‰¿EgâVğ¤?\³©{ãòŸ¿¬½á«µ?÷“0ã;“¿¹=UF¢Š¿Ÿ7OÙºl?¹×0à¸Î•?±îµv­u?3›€Ûs¿2lqæ‡¬”?/(Ö àf?J$òÙ¹ª?¥ÅğCkf—¿+ìÙÛ|®¿=J.¸´¤¿¡á»7 Ç€?SÔpüš¿Ï²B™ÿ«¿Sİà¢Ó.g¿àãD¢mˆ£?‡èn`ô‘B?¼‹g8´´œ¿ÚÂÈÒT¿¤å¾îW°?XŸ· wëœ?NiŸ¼ÿ÷§¿_kçâQ™?Ç†>À2Ÿ¿»EÅ uYZ¿ßÂnc©±«?İ±oÄæ¿ës@@.¯¿ÖÛ,:õk¿¨1¥76¿\ÒDäc“š?İIšøĞ)¿—UÎšüo‰?ÆvWs	Rˆ¿‹*N{k|¿(NX\È•£¿øÒŞW5™?Äe$a0–©¿i¬yeIF«?WG[ƒa:§¿<ÍÌCÛnx?¹p½ùO/¡?Y!ØıÒ¾?Ñ8ágâ‰¿ …C¤ã¥?ŠBf	«?©Hí”úñˆ?ãß’Ü”?ty…z™?”cÅÀàùu?póö‚w; ?H•İs—¿ÓCŸU‡X˜?](Y3‘¿ D'oso…¿	¢Ú©7‘?¨ùğMO/©¿±ü›É—¡¿OîşN‹”¿òWª°­?}«@ğ¢ ?2|ú¾n¡?À»K˜n‘¿˜Ã§fú¿fwÔÚ¨?_/„Å—¡?ÄØ1„?ë.šßz^¡?ı=½Á3{¬¿ô`ÿ3R»¿â;å\€9—?jtÂÜÒ—¿´WkÂš¿‰Ùy®şœ?-f Ê²¿=S…”tl¿öÚfğ†¿óÓqë$£¿1k"f]€?*zôG—…?$ÔS~.'¨¿@^B¥«¿ú¢é^ºX§?eç¢^Fj‡¿×ºš]s¥?İcá·ß—?*SÅ>ÌØk¿DZCï±¿è_Iô]
r?¶èaËD¨¿¡\"09bŸ¿Ÿ…}-:q?Xm;ÃÁ¢¿şàOU¯¿ÊÅiŸÆq‘¿Õçîcš#¤?†ÅM²z,–?§>J›t¿IfX9r¬¨¿-}uÊ\†?éiÔĞv?¹”¤
Æ ?4²p„é‘?Šš)¢ßmh¿+ø¼]•q¿|nÇ©”]K?ä”~—YQ¿û{ç–0µ?TLkôæG’?‘˜pMY?ÎC¨}3dŠ¿ñZğ?…eˆ¿…>n=×wm?0v¹T”¿^LÏ‚£¿)î1¾Sô¥?óJ“Ã ±`?  U/ºŠ¿0B…ŞsD¶?8‹´à‡{Ÿ¿Û¡Ä[¥±?8©I©¡¿şêÅŞøË¿»×7šñ‡?¼Ty7¥?	N ?‰?-5²“˜v?•Ì¼9‰?9šš9a‘¿{ÕÈ2íœ¿I:@åS¯?8Œ¼‹{—¿k3FX¡¿dd°^¥¿ùÎ­/T¦?FÎ»H>š¿„˜ÿ,m±¿€<5C~˜?UhƒÀˆ…£?§¿£5"ò‡?¶5`x¢?tÔ {Éœ?Îw½"bÄ¦¿ß•{†[¿ïŒcæ`§¿ÛÀÛ‹Ø¿!Ø†Äˆ£?Ù)ÒÔQª¿Ô	‡æ
g?‹ìŸ©±–?¼½…$œ–¿ˆş¿ ;w¦?hÍ,•ù?®¿|nÄ:%…q¿Gbb/×Œ¿E¡yÁ&¹‡?%± ¤Ù¿<ÙÍŒ~4 ¿71ù¦¶Â–?¸AŒ¯¢¿>˜§‚pVƒ?(µÆ‰w¿ï3g½±¿^HaÀò¤¿#?™õx”¿Ùw6Å’[ƒ?ºêÿñeoƒ¿ë¨j‚¨û’¿Ï*%™Ã?-Tà_bş ?'²ö‚Màp?‰Øæô˜?â‹_áşv?"`ÜÄ’?NeV5x¿v„¿0Ú£¿`Úî ¡&¥¿Ã;äY¡?`³‘(
­?ò—³Ê…?
+ÄU‰¿NC$¨¹“”¿ÉÇî%§¿QÚÙ_ì–¿SÖ| €«?ºYãûÀg¿dÒøèM¥¿£†Çb•¿ùY½§˜¡–¿—İ$•PB?·\¢²í¬¿'GdÌ/š¿!ª2„Jù©?; £Œ³?·sŠ#Iï¶?ÀyU¶ôF? -¨svW¿š“–k‚w?¢˜¼f>³¿·d£½£?Å+¡ŸÏ€?4HZë.E?Sª&ƒV­¿ƒå=˜y„¿û3e¢f£¿FGã%?s?ôXL“?¢€Ca}'²¿ìéãÉ˜?.ô¢´Gx¿Xmn^›¿!†Ê}z…t?Öú€/‘¿T³À;Öœe¿ ¬ËR—?ı£ë™œ¥¿L[V|€¿[{<€‡š“¿w?—>®ì†¿ñ<+ÿ—xR¿)å°Y ã•¿·É’[ˆi¿t —39‡?g"ğ°1¡?ØuºñÃ–¿‰°Ò¾hxŸ¿~4AyÄ°¿À!ÆşÁ¦•?±$ò½¼‰¿¶{Áƒ?,âÇÚ×h”?ÿ‚+@Ş"­¿t00e¿r‘?t|ÊÖŸ™¿
<ËÂËÒq¿Üw+œ»•…¿D2!<“cš¿…üÄåˆ¿ÔÍóâ§›?–Qãàı±‰¿\`êB¸¨?¨HğL‰ ·?§ZMÏ¢”?Ÿ²Ï ÷¿=',Ã°¿ûÛ !Ü—“¿Î­¼VÕÚŠ¿*»‰ïşW£¿&êÜµª¨?†…ÅnÀc¥?s)Ç)‰?§¹Yßg,¥¿8fÏ!M¿ïì:¸v?;gğ Âëv?9	¡…œ|? x2¢.ş€¿SAfã˜—‰?Iá¾1«Gƒ?ø3Ë„÷†?^uç ö¢?Şúv3ç²¿‡Ö—`É•¿Ëóº'
R‡¿,¾È§Íé¾×Sà¡~–?7ÛØÜz?¥~æÅìÙ©?6FÌO®?úàzé-ë€?ŒîÙÅ­?Ë¶ä¸š›¿¥‰²[’?éÜå	!s‹?¤‰rÇmÄ›? ZäêU?g›gaY­¡¿³N½·¿à:µé¾R|¿|Ì»$­„?>Íê™5ãŠ¿I
÷Y=†¿LßŒwî¹?¸Æš£$ª•¿Zû\rı®¿uùŞø=^²?<ºyù‰BŒ?›J5Ü°?¶îÍn­¡?KÀÎâp’¿Ór úñ’?”<©¿ö}¢?“şâ¥İ€¿_å‹à¸±y¿Su>’­?m½~?7_§¿ğÄü9qm¿nL·;WÓ¿$y©6
Ù?r#û…‡R?Gş
à u¿€¦îbK£?z ÓDbE¿D5Şƒûô„¿ÖéõÉ?Áª›‡Iš¿Õ "&Â™¿@·€iºz¿pŸµØv¥–¿<81ASU?PíâÓ¡¿Ïx²´¢¿ZjC8š¿“æÛ÷²1”¿Y gê§¿–e@D
”?YïÂ^9R?‡Ë?B«?$ÏX¨ó°•¿U¢¿A«?òÒC:l?^¿ÜşÇÏ‹?Whil„…ˆ¿†µçè§î³?2 œËä‘¿WÛ›¾¤¥¿Ç-7/†&€¿*Cå÷¢?D×èIW¸?‹ûÖ!ı ¿”¬»`#µ?$;Çd—Æ”?µ{py×™‘¿«¾Ú\3<X?ö2‘Ÿ{y¡¿€ÖM@K¢?"\±; ¿>È}n”?Ã}‰2Š’¿¾.œŒÇ ¿núK<´P™¿İçƒ¤Kl?1VWâZ‘?Šc/¤[`¤¿VEÿ4á¨?B¬Ä]9R§¿k7°õª¦?-ÍÎ? ¿ÜËè ˆ¿Ür¢i ?µÎlÌ±w¿”/GvB²?Ré_F<ÏŸ¿ö\Äûš¤¿À%VÿM™¿8VÌ‚5@¢?5 ±¯L†¿3ŒëzÊ³p¿ì@âÆIª?d½ëHÈ¿3`‰:…ò–¿IË—|8¡¿­Øy4Hr¿Ï{eÄ²Â÷>Çâ¦"ïşC?ø•¸¢U¬¤¿ØŠÆrüd}¿»Eı´÷¨?’^P¶³uq?HƒŞP5”¿fßŞCn¤?BÅŒ~¡8«¿!p‚Ab¦?„pÀ?‰õµ¿Qùı¹m‚?F‘½÷š’z¿Åyr,s¥¿ZÌõ;t¿ò°—@&&©¿Azqb¥¿›>éD‚•¿ïSœ=¬Dœ?Ûò6ÛßŸ?L"Bs?%6'HÏ!Á¿§ÇVš‘?xóì£g;U?‰7|¤?f!®Z¡a?“ˆIèÉ]•¿ƒ” ~‹¡¿×ëd"€?qÜsªÆ\Ÿ?Ã{*v‚™¿còR&?&Ÿ?AEéÜz·|¿
R¡1š¿¨RÜ=låV¿+x2 ¿•+ vÂŒ¿½¿æÁ‚Œ¿ÚµEÚ¬l¿j’ZS›¿Lá’úê^š¿’rK9Ìˆœ¿óŞ½H“?MMşşÿÅ¸?Œšç<îQk¿<ş²K¹š?i<Ï§§ò®¿9E&dí¿¹)	|Š‹ ¿nşÛ<@£¿üRÍB¯”?´Œ˜üì±¿g<ø&Ù,­¿ŠÄ¤ÂOQ–?UœQ+7©¿µ;À¿¿t©:yË´…¿„Å¥ û“¿ @An.€?“©C§‘•?!;•˜?’ÎWI?`…hÛ)”?ËÉY˜¿È“æ‡ø$¸?’¢ …Ù£?å.!bìD^?¦pá™ ^™?’t0WÖ¡?Ş¶*".4?:^¾0 ?{gm€½µ–¿Z8ÔåPc›¿uÛ2Ó²¿—ÈGƒÂ=¡?Ùå!tLí¡?EŸŠy(šO??ÌşUª?£Hé©@©?zP‹£$;e?ÀÂÃ¦?ØD‡<Yœ‘¿öö˜\M«¿´eäÂg¿-O,_³6«¿¤*             ´*                     ## Setting Up the Indexer  In this Seaport indexing project, ourÜB      C      ## Setting Up the Indexer  In this Seaport indexing project, ous,C      lC                      ÔB             C             lC             v   
content ÿÿÿÿÿÿÿÿÿ*string8
3vector ÿÿÿÿÿÿÿÿÿ*fixed_size_list:double:7688j
lance0.17.0z
lance0.1{   ¼‡ ´…*m
0 ÿÿÿÿÿÿÿÿÿ*struct

null_count*int648
	min_value*string8
	max_value*string8 ü†6D         LANC