# Multichain Quick Start - IBC Transfers  <!-- @include: ../snippets/final-code.md#start -->  [IBC Starter Example](https://github.com/subquery/cosmos-subql-starter/tree/main/Multi-Chain/osmosis-cosmos-bridge)  <!-- @include: ../snippets/final-code.md#end -->  This tutorial provides a comprehensive guide on establishing a multi-chain indexer for indexing Inter-Blockchain Communication (IBC) activities among Cosmos Zones. The tutorial demonstrates the integration of bi-directional transfers between Osmosis and Cosmos Hub, while also highlighting the flexibility to effortlessly include additional chains.  Upon completing this guide, you will gain insights into effectively correlating event data across multiple networks. Furthermore, you'll acquire the knowledge to configure a SubQuery indexer, enabling the monitoring, tracking, and aggregation of events from various Cosmos blockchains within a unified entity.  <!-- @include: ./snippets/multi-chain-quickstart-reference.md -->  <!-- @include: ../snippets/cosmos-quickstart-reference.md -->  <!-- @include: ./snippets/multi-chain-cosmos-manifest-intro.md#level2 -->  Beginning with Osmosis, the manifest file for this will be as follows:  ::: code-tabs  @tab `osmosis.yaml`  ```yaml dataSources:   - kind: cosmos/Runtime     startBlock: 12427162     mapping:       file: ./dist/index.js       handlers:         - handler: handleOsmosisReceiveEvent           kind: cosmos/EventHandler           filter:             type: recv_packet             messageFilter:               type: /ibc.core.channel.v1.MsgRecvPacket         - handler: handleOsmosisSendEvent           kind: cosmos/EventHandler           filter:             type: send_packet             messageFilter:               type: /ibc.applications.transfer.v1.MsgTransfer ```  :::  As evident, we are in search of two types of events â€“ namely, `send_packet` and `recv_packet` â€“ representing outgoing and incoming transfers, respectively. The information from these logs will subsequently undergo comparison with the data emitted on the opposite end of the transfer.  <!-- @include: ./snippets/multi-chain-creation.md -->  ::: code-tabs  @tab `subquery-multichain.yaml`  ```yaml specVersion: 1.0.0 query:   name: "@subql/query"   version: "*" projects:   - osmosis.yaml   - cosmoshub.yaml ```  :::  Now, we have to indicate that we want to handle the same data from Cosmos Hub, which data will be matched with Osmosis's smart contract data. The manifest file for Cosmos Hub will have the following look:  ::: code-tabs  @tab `cosmoshub.yaml`  ```yaml dataSources:   - kind: cosmos/Runtime     startBlock: 17934016     mapping:       file: ./dist/index.js       handlers:         - handler: handleCosmosHubSendEvent           kind: cosmos/EventHandler           filter:             type: send_packet             messageFilter:               type: /ibc.applications.transfer.v1.MsgTransfer         - handler: handleCosmosHubReceiveEvent           kind: cosmos/EventHandler           filter:             type: recv_packet             messageFilter:               type: /ibc.core.channel.v1.MsgRecvPacket ```  :::  Here, again we are relying to the data of the same events. Events of both chanins will be processed asynchronously, without a specific order, and will be matched according to their data.  <!-- @include: ../snippets/schema-intro.md#level2 -->  ```graphql type BridgeEvent @entity {   id: ID!   sender: User!   receiver: User!   sourceChain: String   sourceChainTransaction: String   destinationChain: String   destinationChainTransaction: String   amount: BigInt }  type User @entity {   id: ID! # Wallet Address } ```  The primary event is the `BridgeEvent`, which contains information about the execution of the transfer on both sides. It will be completely populated only upon successful indexing on both ends. Further details about the logic will be discussed later.  <!-- @include: ../snippets/cosmos-codegen.md -->  <!-- @include: ../snippets/cosmos-mapping-intro.md#level2 -->  ::: code-tabs @tab:active `mappingHandlers.ts`  ```ts import { CosmosEvent } from "@subql/types-cosmos"; import { User, BridgeEvent } from "../types";  interface EssentialValues {   sender?: string;   amount?: number;   receiver?: string;   sequence?: string; }  async function checkGetUser(user: string): Promise<User> {   let userRecord = await User.get(user.toLowerCase());   if (!userRecord) {     userRecord = User.create({       id: user.toLowerCase(),     });     await userRecord.save();   }   return userRecord; }  async function getEssensialValues(   event: CosmosEvent, ): Promise<EssentialValues> {   let sender;   let amount;   let receiver;   let sequence;   for (const attr of event.event.attributes) {     switch (attr.key) {       case "packet_data":         sender = JSON.parse(attr.value)["sender"];         receiver = JSON.parse(attr.value)["receiver"];         amount = JSON.parse(attr.value)["amount"];         break;       case "packet_sequence":         sequence = attr.value;         break;       default:         break;     }   }   return { sender, amount, receiver, sequence }; }  async function populateValuesFromSource(   sender: string,   amount: string,   receiver: string,   sequence: string,   event: CosmosEvent, ) {   let bridgeTransactionRecord = await BridgeEvent.get(sequence);   if (!bridgeTransactionRecord) {     bridgeTransactionRecord = BridgeEvent.create({       id: sequence,       senderId: (await checkGetUser(sender)).id,       receiverId: (await checkGetUser(receiver)).id,       sourceChain: event.block.header.chainId,       sourceChainTransaction: event.tx.hash.toString(),       amount: BigInt(amount),     });   } else {     bridgeTransactionRecord.sourceChain = event.block.header.chainId;     bridgeTransactionRecord.sourceChainTransaction = event.tx.hash.toString();   }   await bridgeTransactionRecord.save(); }  async function populateValuesFromDestination(   sender: string,   amount: string,   receiver: string,   sequence: string,   event: CosmosEvent, ) {   let bridgeTransactionRecord = await BridgeEvent.get(sequence);   if (!bridgeTransactionRecord) {     bridgeTransactionRecord = BridgeEvent.create({       id: sequence,       senderId: (await checkGetUser(sender)).id,       receiverId: (await checkGetUser(receiver)).id,       destinationChain: event.block.header.chainId,       destinationChainTransaction: event.tx.hash.toString(),       amount: BigInt(amount),     });   } else {     bridgeTransactionRecord.destinationChain = event.block.header.chainId;     bridgeTransactionRecord.destinationChainTransaction =       event.tx.hash.toString();   }   await bridgeTransactionRecord.save(); }  export async function handleOsmosisReceiveEvent(   event: CosmosEvent, ): Promise<void> {   logger.info(     `Handling an incoming transfer event on Osmosis from ${event.tx.hash.toString()}`,   );    const { sender, amount, receiver, sequence } =     await getEssensialValues(event);   logger.info(sender);   logger.info(sequence);   logger.info(receiver);   logger.info(amount);   if (sequence && sender && receiver && amount) {     populateValuesFromDestination(       sender,       amount.toString(),       receiver,       sequence,       event,     );   } }  export async function handleCosmosHubReceiveEvent(   event: CosmosEvent, ): Promise<void> {   logger.info(     `Handling an incoming transfer event on Cosmos Hub from ${event.tx.hash.toString()}`,   );    const { sender, amount, receiver, sequence } =     await getEssensialValues(event);   if (sequence && sender && receiver && amount) {     populateValuesFromDestination(       sender,       amount.toString(),       receiver,       sequence,       event,     );   } }  export async function handleCosmosHubSendEvent(   event: CosmosEvent, ): Promise<void> {   logger.info(     `Handling an outgoing transfer event on Cosmos Hub from ${event.tx.hash.toString()}`,   );    const { sender, amount, receiver, sequence } =     await getEssensialValues(event);    if (sequence && sender && receiver && amount) {     populateValuesFromSource(       sender,       amount.toString(),       receiver,       sequence,       event,     );   } }  export async function handleOsmosisSendEvent(   event: CosmosEvent, ): Promise<void> {   logger.info(     `Handling an outgoing transfer event on Osmosis from ${event.tx.hash.toString()}`,   );    const { sender, amount, receiver, sequence } =     await getEssensialValues(event);    if (sequence && sender && receiver && amount) {     populateValuesFromSource(       sender,       amount.toString(),       receiver,       sequence,       event,     );   } } ```  :::  This mapping file is designed to handle events related to IBC transfers. The code imports necessary types and includes custom types, such as `User` and `BridgeEvent`. An `EssentialValues` interface is defined to represent crucial attributes like sender, amount, receiver, and sequence.  The script includes several event-handling functions, namely `handleOsmosisReceiveEvent`, `handleCosmosHubReceiveEvent`, `handleCosmosHubSendEvent`, and `handleOsmosisSendEvent`. These functions log information about incoming or outgoing transfer events and then call the appropriate functions to populate or update values in the `BridgeEvent` entity.  The code has the utility functions like `checkGetUser`, which asynchronously checks if a user exists in the database. If not, it creates a new user record. Following this, the `getEssentialValues` function extracts essential values (sender, amount, receiver, sequence) from a Cosmos event's attributes.  Two functions, namely `populateValuesFromSource` and `populateValuesFromDestination`, asynchronously populate or update values in the `BridgeEvent` entity based on whether it's the source or destination chain. In this example, we utilise the `sequence` value to correlate transfers across diverse networks.  ::: tip The final code of this project can be found [here](https://github.com/subquery/cosmos-subql-starter/tree/main/Multi-Chain/osmosis-cosmos-bridge). :::  <!-- @include: ../snippets/build.md -->  <!-- @include: ../snippets/run-locally.md -->  <!-- @include: ../snippets/query-intro.md -->         Ò'      ÕmtÁ%o˜?UôŞ«e—¿ÿ8MŞ³¶¿6PÂG"š¿ÛjÑ`%¯€?ğJù’‹˜?é‚zò)òV?o™åHí™‹?ƒƒAÂÅ–?Ä[$CGØ‹¿ ^[RŞ?«°|
>Õ®?4Å5¡½8±?]3‘ƒ&J­?µ›&•,Q¿ÕP¯â­¿5Áé½.L¿L†¤k}?«’¢à¯?+"¤ `¥?xå€°Şw?6KÛ_[¿Î–Ï™„p˜¿4¾ãŸRl?Q÷"VV…Æ?¦¥%ß¨?WQ†!§ì¯?}s‘ØtX‘?Ğš@Rt³¿ÄìDÍ€¤¿pûÙ w7¬?h6ÙP{[š¿
Ò,Ó¦‰?ãg+H–@¤¿¸Æ2À¯Ø…?¬n~R³‚¿¼¦0„Ö¢“?PŞlª¥?¸æ±¿\4 M%Œ¿„í•õƒ?ÜÍ?9‹”?“Hñİ%ò£¿@Ö±±®¤¿Æ_ç¢9¤l¿"Ø½k‰’¿B”¡½	¤£?ÇtÀ,ïƒ?,'Aùd¿´ÙÈİ6?§¿UgZ¬Á¦¿¾~áÅ]å¿¨J ’Iz¿ŸJ@°¿µŠßµ¶°?´®`Bİ,{?¤¦æ=‘Ñ¢?W¤ÿK{V¿ V' Sb¤¿ Í4ä´T¿füÃâ¬š?ÈÓHb¤?km‰xÅ5¿:g¸¿‚M’?…±Àa¿G¿Ìc-œ¿‘qUÂŠh?{[bÅ¦¡?åÌ©vãc‹¿ÓîÃ(¥¦¿‹®#B¡?µIÛ~Md‡¿…FåcÍ¿vZû_	§?•9˜x ¾™¿“üªŒ‚¿R+|S+ ¿{½ûã½jŸ¿ Îêôî?ÎrYÀŸ?õ
ÑB~©?jVëI‘Š?õÙ¿ºCí¶?ÍÅÕ„‘·t?ºä…b•Lr¿H/:¾•£”?üd,†‰?U~¿ñå˜¿–Ãş˜¨¿‚—N(šÀš?9Çğ@³×Š¿ò7©I¢?º}îŸ¶?ÄşÄ^®?…”ŸTût²¿…ğ¿¶ú“¿ÂoàaT?	.´Eb›?.üdµä©¿˜šIC©—¡¿í¼l¿¥1†¿·­|‚Û†¿(3Ûë¾‘?X*Úâ;­¢¿¦:p¥¤°? â#‘¿¢ı¼í^?ŒÁ‹
zŠ?	/ïáúÆ“¿¸¨Ijğ†?—ÄİIÙ\ ¿ßÌ¶?%h£Y*”?àu¥ù˜¿c}İËx¹‚¿ÜÓ8HFÖ¡¿ÍU[ Á ?¿.#òæ;¿mö… £^?×úà„[¡¦?V ê¦ã‡?hŒ ßïap¿eà¥8,¤C?İJQ\ÅJ­?vp”âj¯¿(í–¯ƒ?BŞùå–Í•¿ˆ-EÂ?*ûÁEO•?Šßcœşmš?±«–b±Ç?òv$aV]¬¿‘²Èw,T?·5 àÅ}?	ÅwŞç¥?£§LZ†r°?€Ák (zb¿×Y§gÍ“¿'İâVK~ƒ¿F ­½³¤u?ÛB*¡ÈN´?y3ä„{ø›?&|Ì±‘?.l¯ ~¡¿o{C`3`§¿ušıhÕ:›¿xB¯?‰Ï‡?cš
m©¿¾Ü¹…­[¿7ï¶T¿Ğ.D&—–?›Ç£LQË ?®÷½{·Ÿ¿•Ê‘?/Èìå¤˜?µ2Ú‡œ¿¢&Ôµñ?ÃÅ²â	¢?‘
¯™†%—¿Ûş¤ÀSß§?‹Ä{C?;vŠ4uG¨?Òx@ŞMå¬¿$>c5€¿¼õS i}¿q8VÖô¨­¿ÅyĞ?<¢ÿÌ“?`RJùáˆ[?•¡òûsÛª?’Öñ>[>{¿‡#xÔ|™¿@:Q<k™¿ë¬ÏØs¯¿œX–Ÿ±?“
×aTkˆ¿ìSÈtl-¥?šP_“P\?P~¸Ï•¿¤.ß¿Ç©¿¸Í83¿V)^á´°¿b¦Û|€¤?{áO§;X?ÇÍs»Ìí˜¿—à$d½±¿şø>aø¤¡?t4š¨Sƒ¿	ÚBbK¡¿'_‰Ö¿ß2QË©y‹?ç8Tß;b¦¿ÒJOÈ6¿‘¿şD#§È€?¯=O¯¿LäùAš ¿©Ù²eÁ¿F´üDB¦?©¶Ö~?ø	V‹>Õ§¿a¤¥_³‡?t±€A†–¿A0:Ğ§¿a…HĞ7t¿9\*½Ö¨©¿{ TÅ(R¿<µ•¿Äˆ¿[Âƒa®¿8{GA{™¿'ƒµÇ‘"š?lI?ÈO´?[®»ÏªüŠ¿vô¦¿ê
¿ªFöÛ³»ƒ?"x'¸Œ¿ÀSÕ¿|–¨¿*Ù¹‚Ğî¤¿ÿèz&$g«¿2¾Ÿ‚R¥¿ı/¶”E¢¿äì{üŠ?®¡¡mŸÏŒ?Ö%º™—ä°¿2ÄóJ@é°¿êcW½p¥f?¬ÕÕŒ˜˜?‹^ŠÎÙÒh?áûH5ßÍ¿.ªáƒ “?Ü5Òf]"•?gêùÃdä¥¿.IIC¥¿ûZÿıq¢?Û>Àgß‘?R“<S¿¥?ëH‘Î?YøÕ¸×X?EÜd §­?Ø"½6ˆ‘¿»´DÛïX•?¹ÌI%Å’•?­¿¸cĞZ„?HFòÁ¿Pª‡¬‘…¿»E²¿`D\¨¿äø»ñš­¿ê·È ‡±¿a+O½ÁY†?¶ñnÿ¦„¸?8Qœº*“?ÓbuXŸ®¿åLşŞ’?Wà.r­?ö±êÂûé?•·ã\S ¿Z€•ÇÃ§¿hË†X•?•˜ë]Q„‘¿X Sª¿±?4šà?ÙùG‘¿M½¿Xk‡?˜²Âã‘.˜¿Ø§¬>œ¿rÛ#¼o¿ÀrJaZ« ¿Ì:t^‰^™¿Š#©?]ü]yû—¿òÃà¦–¿hYÖœÅ£?O›‚ÕF?š„âùÒ–?>ö'¯A~?÷áÊ /p¿Y!İ¶Œ'„?BQMº‹?{ª¨™l>q¿Ñ!p$Ğ`‘¿ñ6*È³ñ–?âò7Ü)Ïc¿e›:àÑş—?_¬VÃÑ—”?º“ÑÆæê”¿Kh»×ƒ(±?G%ˆÁ[ci?.»Âã$ ?>UOïlË<¿Prù¢L‰‰?uq©·÷Š¿ëÉLÆI
i?U5¸â ¿ßñXù†>µ?şî€_á,ª?2ÂÇŸ)í©?Wş„Ìø§?Qv:]€?0¹!+—Dˆ?˜¸ 3—š¿~»å[W„¿§=Ê9ğƒ¿ïÕ\¨Û]¤?¶N‡´†?ìØôßX ?ëZƒ‘å ¿J>®Á†—?#ˆ¹|YÎm¿r4Õ –v£?\Dc–¿LïÙ¨X(?ÆåŞê·z¿ÍTŸãW“¿~Ö¸ÛN‹®?Ñ°¦Å¯¿ÄCÛÛt£?—&¾=|W–?ßm@]’¿pàŒœ°½¿~d¥~¿D[^QûÁ?”WR"U‘k¿'Ë%bPˆ?çEN¨¥•¿è`|®Ÿƒ?] ‹#bŒ°?ô/ùB°p?Ì ùq~‡?Qh–Z¨bv¿¸X™¿iÓUİÊâ¿$B©Z§a?˜ïez@ƒ¿ÂJ?W?°¿[zª¾½{?é£3 ¹œ•?ô`	¦ÅÙ™¿Á“€ü½.?]ü!ÁJÁg?^§ Á÷ƒ?—$K½Ù¬º?»
f¢ÁÓ ?0øà¡ƒ•?VÿRÌbŞ¬¿Iw?‚›k?»J†Ë?*®û,n”¿ëµ¯4×Š?ÄÄşºª?ñ¥À¤Bd?.D^A`©¿˜ëæBâ§«?¼I%ŸË’¢¿…#ü“‚¿w¾¤ÓèE…?G’Ajê§¡?±IUÉ¶µ?Gw®?Â¤Íx(ø˜¿ë«Ö‚p?ãh]ş¨?ò»•—³¿B*õÇÜş‚?*ì<r¯Q¿@ÔÕkx?1àÿ£C›£?ö47Ã/±?>6z×Î•¿l5±áe­?Ù+ß»•r?†d3MùŒ¥?K‘Q¥3‘¿('cG¦í–?Y"£E®‚¥¿Ø¡y„Ã ¦?-q‰ÈUÑ ?ïPY\§¿ğfş²*«?Ê•r¥;Û°¿yÖ$.¶ÿ­¿ØaN¹?^›2Ü%…?sç@¶˜†?a+Jñ ?uvb³|…¿âÜ?»èš¿Páìüù»‘?ØTí,Ú³?§Ò´c¡Ø?Ü‹Á˜4›¿ *¡|ÀŠ¨¿qÙ»4¡¿¨·ã¦6¡¿kÖ‹€—¿.ïÍ€¿'g'Ö’?y^¡DˆŸ?÷FĞ?‘Œ ¿­BİÄÚq¿N¥—ÿ-T¤?ŒÜı'“?o¡e¼1-°¿
­â(p?ÕuêÂö0s?ÃÜ§ ? Á. :X­?7ÜĞ_«®„?ãö²ŠŠz¯¿Õ22½Æë_¿H¬lï¸„?Œ`]Á¨7–?ù”ô_ƒ¿©®N^ü ¿Î`ß>”³¿iíl~²˜°¿GC$#ˆ¿Â¥BÀJÓ±?Jé—–¿ˆ\R°¯¿ëÍzÁ?V ?Ø#yS6Q°?è ®b¯Œ?‰£@Ùs?5|'@öu©?tÇóıú?š¿5n½è#×¦?Ë+Û­A˜¿@7iWwå€?ÊÀ¦sêo^¿Ö2?4ˆ¿v¢Éj_åe¿´…ï«z›¿ß4à {Ş¥?Ç4ĞÀ;¿Æf¨Š`ÕM¿´İæŸv‚?”?ÎêÓàˆ¿•È ;
¡?çMÿ˜?É'W½kìd¿S¯îg—À„¿‰÷[¼Ñ'¡¿WÙ8ynŠ¿]ÄŞ= ¦?\ïPwÏ£?ÀËoE f±?…Ï«Aeêš?!M”;n#œ¿#¤„ê§©¿ië°Ş9/m?¤+¼:,õa¿!§İW9£?°Ût¿›Rœ¿ìïZ¾¡?F)±£¥?d ¿~<‹?$Fİè¡? vA¥“j–¿G~x÷W¿Á¬4@¡Š?ê'Õc¿]¿ù!èÈÇw€¿¤ª±J
¤¿­5Ä¢Ÿ¿ÅTó*b¿lV_X\îœ?øŞØ¹j?KwZí“¿q7½ù_I?†Edc«?Ytio¯¿*3OõşŒ?•6#hò ?,¶øıcm¨¿şÓ›¾„„?oÒ, qÆ}¿S*®ó‹¿ÉáY£ši®¿4ÚÎ¡
g¿ÉÛŸj‹_å>Å®H§	6›?.ğ‰3ª­¿iòŞbš¶¿b±g~k¬¿E»wÅmã¿\¸ƒµŠ˜?7ÍÆ@Z@}¿ ¼i?Áá¨?ƒ8×|Ñ(¡?µ¨ñ †M‹?9æDÔ§É?Ğ~ŸÏRB„¿ä
º€A›?+J®8)¿œ“ĞzÕÚe¿àX}™œ¿÷Iú#(X£¿˜ì“4c÷?õ@pÅi”¿!6`úØ?[N’ÂÆ‚t?ıC_4Ø®?g©ü8ˆ@‡¿T O¸ó‘?ËÏWÚóF©?ßá>#¯¿ÿÔ°^€¿ÉAÂ$èª¿{<€‡šÏ³¿wÒ«¿ºW?TG‡º!#¿óD¼çSÖ•?n;Şm©¢?ÌpÖ¼·İª?ÖŸ4<™¤?ÊzÿYÒÕŠ¿ÀZCZ¡?Æ3B!ıTŸ¿ø¾Xâxs£¿{S 5EŠ?Ø‰Ë¨ëmP?F£=‰È­¿ºß=8† ¿e>‘¿Ûæ&g±ß’¿ cIµp?Æ µ­‘¿Ie«Gñ\¡¿ú0F o?¨»>µòy ¿JŸäãš?Z³£æ#c¿¯w)¼Ä©?1×y†6!…¿§IÜòˆ¿ŞCxjä©­¿ ç7ß—¿û=±N•ï¥¿›ğTì\g¿Ewœä?‹®?%€ü\İ‡y?fjĞŸOG£¿ñ

¤@v±¿V‹4cdØ›¿;R, ¥”?Û#òbw¿âÌØ´¿ß»ßşâm•?|åùn‚?b7Ç+²¿ª8Î ³b®?$¿¸3—D¥¿[Î3cÂI«?ÅS,º¡¿ÒíÛÿ¶İ¦?UC|Y?Ïÿî†x¿b,¨¯´š¿ÎßË+½0¿›·ç‚Å¤¢¿¡&~µ8¨?OãÅ_æ}|?>óıÊvu?nG¼e] ¿aìåÀpƒ¡¿nêHœ{¿-ôp¢}¿±ÛNš?×¨¼ZDÍ‘?;ğ½^Mº?Ê’àİ/>¡?²ûeb€e¡¿ÚÃuÄÕŒ˜¿Z-ÑÕ-m–¿N\„å¬¨•¿Š¼Ë–«¿rÔ¦:ø“n?ê£¥qö?ø‚±æI—‘¿Öÿ‰º¤°¿Ï9‘ÃÔT–?Âş®yœ<—¿í(WC¥»«?êã%(ñ•¿%ß¶ ~×²¿üçÁ’º¿nR" ú»¿q?§²}ÇV¿ò˜ =«?ó5²Èh±¿k¿Ä>R[¢?“_ƒá‘?]99Kâ¥¿	bcÀ£?¨REñ*§?R£©÷ú”?]ékL>,’¿öøR²{v²?†-Wå¡[?[èÎ<Ne¿¨ĞÙÿ‰\£?_cæ:A–?¨R7@şŒ»?ü„o>Îdz¿$Ø«Ô[`?Ú/+VQ®?~y$æ†š¿ÚÅŒ2­? rÈİR”£¿—Ì«ƒ¿øh¢?3”àû…˜­?¨jºR†¿Iõß{fæ¨¿ª1
JY‹?¿ZUù š¿á ‹à¥òª?¡`Œi"C°¿‹© —¿ÛHŸwß§¿ò’ƒ„“¿+hqşÚ…¢¿Ì÷Æïñ2x?•dL¢Ÿçf¿ HH™?;ŞÚEu¿ãØaéÏ¡¿‚¸ùæ—¿\¤²z¿kåH æHl?àÔ†b1¿ÿßåİé²°?Ö>xHŒù®¿MÂÄ Å²°¿#sˆ_MŸ¿4	â¸İy¿s+Ÿ•¿Ùå!tLí‹?)L‡j$ë‹¿¡“k¦?gÀ½{6ª?+ÿCÂC¢¿’LÖeÕC?UsBM•?^BBê/›?YJ7FIˆ]¿[Üee.?=.äğÍ_š¿G B‚ ¢?¤ÃC?°¿¤f^úÖ?&L³¡äÓ¦?TOÊÛ—?7&<Cf¤¿:(›Qwv?¢'Iıa‘¿ŸD59=n¿,cüaoUš¿Ä	¾ü]¨¿f…yşcb?£c/]†Ô„?N>á×Ír?H ·4[Ò?‰÷óØ\V­?ä]±c|È”¿’J½¡¿“;¦Í¼¯?õÒ²•¿¼7|l‘¿wÅÅp?"³'?±g£?ğfOú)+‰?’Õ3Øb$–¿j<USÌ¬¿§ğ^g£´¿*z‘Ü™?¢òæN€?1c¥?9Ì?Êí¤?æ{q¢va?HÁÅ~¡¿óĞN8
?ó`^Tˆš?­%¼»Ğ‡™¿'ß!Ğv?Ş¾šE E¦¿õ7,Š5¡?Xjæ^š†¿ª™µö«¿r`w`Y?zQNÃÖ½€?<I_­|´¿^P[ú@œ?#{kı€I¡¿+ ˆù}õ„¿¢Aş–¿uük’x¿°â®¿ŸâÆš‚“¿‡["3ñ¡?EÓùˆ¿>Á|´c£¿½KD à‡¿×’IÏ¦£?•/ÃÚs³¿Ÿ#™¥Æ“¿xİNg– …¿M%1x Ú¿Â¦a´Åˆ¿ŞÇ4Gb“?ÊïbÑÜ ?L{"ÕT¥?@åûw·´?“j§ÿ$­?õ^m¦ñôœ?›ı òÅá‡?2ñ•à×¿–?¡{½˜¹¡¿•Ó,=‹¿¢¿wtĞãÿ§?Bp¦Shj£¿³ìà‚¿uÌœü¬¿¶Ñ¡ûz¿8M¬şRt¿Êş7ş]²?àüŸ&§4µ?):$ ¿à7ti²5±?C»z}ü‘¯¿ÈÒ–YÕ©’?T(8adP?@!3şœ‚¿Jm 6 š?AD%¬–?A‘mõ©†¿ N´OBM?7µRY+“¿¦ (ø‘¿Û•éÙ¤‰–¿šs¡i¾‹?pÄæ%÷"£?Õ-¯SÉ£¿y2(hÍn³?#E_¨¿ â§Öãƒ\¿äL4Äˆ¯?3µ‹ºíz—?§ærƒ¡§?şRşš#x¿Ôúb!›¿;j3ë™ ¿©§'İª¬«?hy#äL›?ü¬lşã­ ¿­±?áĞ¨¿İc¬àşö¦¿ì@Jª¾‰¿5Ú&·?¢Ä`^}Å•¿{öT~ıy¿<òetĞ?ì<[ù4¿g8ñ«´ ¿·¤3È>…¿÷ÀşSÀ)s¿#ˆ(cÒ˜¦¿D5¡ ã›?Ò'             â'                     # Multichain Quick Start - IBC Transfers  <!-- @include: ../snip
@      J@      # Multichain Quick Start - IBC Transfers  <!-- @include: ../sniqZ@      š@                      @             J@             š@             v   
content ÿÿÿÿÿÿÿÿÿ*string8
3vector ÿÿÿÿÿÿÿÿÿ*fixed_size_list:double:7688j
lance0.17.0z
lance0.1z   ê â*m
0 ÿÿÿÿÿÿÿÿÿ*struct

null_count*int648
	min_value*string8
	max_value*string8 ªdA         LANC