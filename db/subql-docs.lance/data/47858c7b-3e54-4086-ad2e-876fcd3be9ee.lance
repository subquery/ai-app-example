# Avalanche Quick Start - Crabada NFTs  The goal of this quick start guide is to index all Crabada NFTs on Avalanche's C-chain.  <!-- @include: ../snippets/evm-quickstart-reference.md -->  ::: tip Note The final code of this project can be found [here](https://github.com/subquery/ethereum-subql-starter/tree/main/Avalanche/crabada-nft). :::  <!-- @include: ../snippets/evm-manifest-intro.md#level2 -->  ::: warning Important We use Ethereum packages, runtimes, and handlers (e.g. `@subql/node-ethereum`, `ethereum/Runtime`, and `ethereum/*Handler`) for Avalanche. Since Avalanche's C-chain is built on Ethereum's EVM, we can use the core Ethereum framework to index it. ::: We are indexing actions from the Crabada NFT contract, first you will need to import the contract abi defintion from https://snowtrace.io/address/0xe48b3a0dc82be39bba7b895c9ff1d788a54edc47#code. You can copy the entire JSON and save as a file `./abis/crabada.json` in the root directory.  This section in the Project Manifest now imports all the correct definitions and lists the triggers that we look for on the blockchain when indexing.  **Since you are going to index all Crabada NFTs, you need to update the `datasources` section as follows:**  ```ts {   dataSources: [     {       kind: EthereumDatasourceKind.Runtime,       // First mint https://snowtrace.io/tx/0x17336f3699f922c245663a50fba2d857c368f6c8137024b980cc2e7042e4df87       startBlock: 30128346,       options: {         // Must be a key of assets         abi: "crabada",         // Crabada Legacy Contract https://snowtrace.io/address/0xCB7569a6Fe3843c32512d4F3AB35eAE65bd1D50c         address: "0xCB7569a6Fe3843c32512d4F3AB35eAE65bd1D50c",       },       assets: new Map([["erc20", { file: "./abis/crabada.json" }]]),       mapping: {         file: "./dist/index.js",         handlers: [           {             kind: EthereumHandlerKind.Event,             handler: "handleERC721",             filter: {               topics: ["Transfer(address from, address to, uint256 tokenId)"],             },           },           {             kind: EthereumHandlerKind.Event,             handler: "handleNewCrab",             filter: {               topics: [                 "NewCrab(address account, uint256 id, uint256 daddyId, uint256 mommyId, uint256 dna, uint64 birthday, uint8 breedingCount)\n",               ],             },           },         ],       },     },   ], } ```  The above code indicates that you will be running a `handleNewCrab` mapping function whenever there is an `NewCrab` log on any transaction from the [Crabada Legacy Contract](https://snowtrace.io/address/0xCB7569a6Fe3843c32512d4F3AB35eAE65bd1D50c).  Additionally, whenever there is a `Transfer` log that relates to any token from the [Crabada Legacy Contract](https://snowtrace.io/address/0xCB7569a6Fe3843c32512d4F3AB35eAE65bd1D50c), we run a `handleERC721` mapping function.  <!-- @include: ../snippets/avalanche-manifest-note.md -->  <!-- @include: ../snippets/schema-intro.md#level2 -->  Remove all existing entities and update the `schema.graphql` file as follows. Here you can see we are indexing three entities, a `Deposit` and a `Withdrawl` each with a [foreign key relationship](../../build/graphql.md#entity-relationships) to the `User`.  ```graphql type Crab @entity {   id: ID!   address: Address!   daddy: Crab   mommy: Crab   dna: BigInt   birthday: BigInt   breeding_count: Int   minted_block: BigInt! # Should be bigInt   minted_timestamp: BigInt! # unix epoch timestamp   minter_address: Address! # event transaction from   current_owner: Address! # event args to   metadata_url: String }  type Transfer @entity {   id: ID!   tokenId: String!   block: BigInt   timestamp: BigInt   transaction_hash: String # event transaction hash   crab: Crab   from: Address!   to: Address! }  type Address @entity {   id: ID! # Address? } ```  <!-- @include: ../snippets/note-on-entity-relationships.md -->  <!-- @include: ../snippets/evm-codegen.md -->  ```ts import { Crab, Transfer, Address } from "../types"; import { NewCrabLog, TransferLog } from "../types/abi-interfaces/Crabada"; ```  <!-- @include: ../snippets/schema-note.md -->  <!-- @include: ../snippets/mapping-intro.md#level2 -->  Follow these steps to add a mapping function:  Navigate to the default mapping function in the `src/mappings` directory. You will be able to see three exported functions: `handleBlock`, `handleLog`, and `handleTransaction`. Replace these functions with the following code (**note the additional imports**):  ```ts import assert from "assert"; import { Crab, Transfer, Address } from "../types"; import { NewCrabLog, TransferLog } from "../types/abi-interfaces/Crabada"; import { Crabada__factory } from "../types/contracts/factories/Crabada__factory";  async function checkCreateAddress(id: string): Promise<Address> {   let address = await Address.get(id.toLowerCase());   if (!address) {     address = Address.create({       id: id.toLowerCase(),     });     await address.save();   }   return address; }  export async function handleNewCrab(newCrabLog: NewCrabLog): Promise<void> {   logger.info(     "encountered New Crab Log on block " + newCrabLog.blockNumber.toString(),   );   // Process remainder   assert(newCrabLog.args, "Requires args");   const erc721Instance = Crabada__factory.connect(newCrabLog.address, api);   const account = await checkCreateAddress(newCrabLog.args.account);   const daddy = await Crab.get(newCrabLog.args.daddyId.toString());   const mommy = await Crab.get(newCrabLog.args.mommyId.toString());   const minterAddress = await checkCreateAddress(newCrabLog.transaction.from);    let metadataUri;   try {     // metadata possibly undefined     // nft can share same metadata     // if collection.name and symbol exist, meaning there is metadata on this contract     metadataUri = await erc721Instance.tokenURI(newCrabLog.args.id);   } catch (e) {}    let crab = await Crab.get(newCrabLog.args.id.toString());   // Reset crab with new data   crab = Crab.create({     id: newCrabLog.args.id.toString(),     addressId: account.id,     daddyId: daddy?.id,     mommyId: mommy?.id,     dna: newCrabLog.args.dna.toBigInt(),     birthday: newCrabLog.args.birthday.toBigInt(),     breeding_count: newCrabLog.args.breedingCount,     minted_block: BigInt(newCrabLog.blockNumber),     minted_timestamp: newCrabLog.block.timestamp,     minter_addressId: minterAddress.id,     current_ownerId: account.id,     metadata_url: metadataUri,   });    await crab.save(); }  export async function handleERC721(transferLog: TransferLog): Promise<void> {   logger.info(     "encountered crabada transfer on block " +       transferLog.blockNumber.toString(),   );    assert(transferLog.args, "No event args on erc721");    const nftId = transferLog.args.tokenId.toString();   const fromAddress = await checkCreateAddress(transferLog.args.from);   const toAddress = await checkCreateAddress(transferLog.args.to);    let crab = await Crab.get(nftId);   if (crab) {     logger.info(`We have seen crab ${nftId} before`);   } else {     logger.info(`We have not seen crab ${nftId} before`);     const account = await checkCreateAddress(transferLog.address.toLowerCase());     const minterAddress = await checkCreateAddress(       transferLog.transaction.from,     );     // We create a minimal version so we can proceed     crab = Crab.create({       id: nftId,       addressId: account.id,       minted_block: BigInt(transferLog.blockNumber),       minted_timestamp: transferLog.block.timestamp,       minter_addressId: minterAddress.id,       current_ownerId: toAddress.id,     });     await crab.save();   }    // Create the transfer record   const transfer = Transfer.create({     id: `${transferLog.transactionHash}-${transferLog.logIndex.toString()}`,     tokenId: transferLog.args.tokenId.toString(),     block: BigInt(transferLog.blockNumber),     timestamp: transferLog.block.timestamp,     transaction_hash: transferLog.transactionHash,     crabId: crab.id,     fromId: fromAddress.id,     toId: toAddress.id,   });    await transfer.save(); } ```  Letâ€™s understand how the above code works.  For the `handleNewCrab` mapping function, it receives a `NewCrabLog` which includes the transaction log data in the payload (it's autogenerated from the ABI definitions). We extract this data the instantiate a new `erc721Instance` [ethers API](../../build/mapping/avalanche.md#querying-contracts) to allow us to make contract calls for metadata URIs. Then we retrieve the `account`, `daddy`, `mommy`, and `minterAddress` from the crabs provided. We then attempt to get the existing grab, and update it with the new data relating to it before saving this to the store using the `.save()` function (*Note that SubQuery will automatically save this to the database*).  In `handleERC721`, we recieve a `TransferLog` from the token transfer, and then retrieve the `nftId`, `fromAddress`, and `toAddress` from it. After checking that we have a Crab entity (and creating one if not), we then create a new `Transfer` entity that we defined in our `schema.graphql` and then save this to the store using the `.save()` function (*Note that SubQuery will automatically save this to the database*).  <!-- @include: ../snippets/avalanche-mapping-note.md -->  <!-- @include: ../snippets/build.md -->  <!-- @include: ../snippets/run-locally.md -->  <!-- @include: ../snippets/query-intro.md -->  ```graphql query {   crabs(first: 5, orderBy: MINTED_BLOCK_DESC) {     totalCount     nodes {       id       addressId       daddyId       mommyId       dna       birthday       breedingCount       mintedBlock       mintedTimestamp       currentOwnerId       minterAddressId       metadataUrl       transfers(first: 5, orderBy: BLOCK_DESC) {         totalCount         nodes {           transactionHash           block           crabId         }       }     }   } } ```  You will see the result similar to below:  ```json {   "data": {     "crabs": {       "totalCount": 28320,       "nodes": [         {           "id": "468847",           "addressId": "0x57a3f535a6edce9fba36af2294462e004fb05050",           "daddyId": "459898",           "mommyId": "459907",           "dna": "618396472672434515354154125260029701206476861469507044587729342789599518302",           "birthday": "1664233214",           "breedingCount": 3,           "mintedBlock": "30160740",           "mintedTimestamp": "1684378541",           "currentOwnerId": "0x57a3f535a6edce9fba36af2294462e004fb05050",           "minterAddressId": "0x45f54251dc012524791d14e5089dc67c5199004d",           "metadataUrl": null,           "transfers": {             "totalCount": 1,             "nodes": [               {                 "transactionHash": "0x0698664b653fa518f8fedb5f620ecd76410ada525197419d65450d7110a31d6e",                 "block": "30160740",                 "crabId": "468847"               }             ]           }         },         {           "id": "468812",           "addressId": "0xfcc9e06736a4700842de9b74a350b6dc8eb3fb9e",           "daddyId": null,           "mommyId": null,           "dna": "455846542712823157032490755191673239445204276297111363276289902986384010862",           "birthday": "1664232661",           "breedingCount": 0,           "mintedBlock": "30160740",           "mintedTimestamp": "1684378541",           "currentOwnerId": "0xfcc9e06736a4700842de9b74a350b6dc8eb3fb9e",           "minterAddressId": "0x45f54251dc012524791d14e5089dc67c5199004d",           "metadataUrl": null,           "transfers": {             "totalCount": 1,             "nodes": [               {                 "transactionHash": "0x0698664b653fa518f8fedb5f620ecd76410ada525197419d65450d7110a31d6e",                 "block": "30160740",                 "crabId": "468812"               }             ]           }         },         {           "id": "468820",           "addressId": "0xe7ee8b644d8938a8a7be599f99c21f618cba3e8f",           "daddyId": "459689",           "mommyId": "459687",           "dna": "491183484008390843624156705206532834116397578442780201281914094049666930198",           "birthday": "1664232789",           "breedingCount": 2,           "mintedBlock": "30160740",           "mintedTimestamp": "1684378541",           "currentOwnerId": "0xe7ee8b644d8938a8a7be599f99c21f618cba3e8f",           "minterAddressId": "0x45f54251dc012524791d14e5089dc67c5199004d",           "metadataUrl": null,           "transfers": {             "totalCount": 1,             "nodes": [               {                 "transactionHash": "0x0698664b653fa518f8fedb5f620ecd76410ada525197419d65450d7110a31d6e",                 "block": "30160740",                 "crabId": "468820"               }             ]           }         },         {           "id": "468816",           "addressId": "0x9a08fa6d83812318caa29772cdffd55a48343c39",           "daddyId": "459941",           "mommyId": "451583",           "dna": "514152495850509839908739572716192611354096695614913321283260330842175907109",           "birthday": "1664232725",           "breedingCount": 2,           "mintedBlock": "30160740",           "mintedTimestamp": "1684378541",           "currentOwnerId": "0x9a08fa6d83812318caa29772cdffd55a48343c39",           "minterAddressId": "0x45f54251dc012524791d14e5089dc67c5199004d",           "metadataUrl": null,           "transfers": {             "totalCount": 1,             "nodes": [               {                 "transactionHash": "0x0698664b653fa518f8fedb5f620ecd76410ada525197419d65450d7110a31d6e",                 "block": "30160740",                 "crabId": "468816"               }             ]           }         },         {           "id": "468825",           "addressId": "0xfcc9e06736a4700842de9b74a350b6dc8eb3fb9e",           "daddyId": null,           "mommyId": "456995",           "dna": "535354660627850451863739142725108770444746476243334240700692594647251497779",           "birthday": "1664232942",           "breedingCount": 0,           "mintedBlock": "30160740",           "mintedTimestamp": "1684378541",           "currentOwnerId": "0xfcc9e06736a4700842de9b74a350b6dc8eb3fb9e",           "minterAddressId": "0x45f54251dc012524791d14e5089dc67c5199004d",           "metadataUrl": null,           "transfers": {             "totalCount": 1,             "nodes": [               {                 "transactionHash": "0x0698664b653fa518f8fedb5f620ecd76410ada525197419d65450d7110a31d6e",                 "block": "30160740",                 "crabId": "468825"               }             ]           }         }       ]     }   } } ```  ::: tip Note The final code of this project can be found [here](https://github.com/subquery/ethereum-subql-starter/tree/main/Avalanche/crabada-nft). :::  <!-- @include: ../snippets/whats-next.md -->         ¸9      	«¶=oš˜¿PŞèß|š¿GeXÿÆ¢·¿Û¦)_Ÿ›g¿êj7i6?@6şÈÛ›?¿êwJÏ’¿r@HŸ!ß›¿__a—¿é.Ã^¬˜«¿}wÈ ¹¥¿#ïÕóŸQ?_È ¤Ä§?‹—ú»oc­?ï²1?ÏP¡?Š¿ '£¿3”˜Õ¡y?QÉÎ„v¥¿NÛ·AŠ}?Ô “?¶” }´Q§?„/=2¾m¿ñéL«¥?‚Ü}BÑ•?9í$€m½?î³%ùT¿}63yQ[¿NGéšÆœ?®8I±«â¿O¤ù8Ú>?à˜ $x’??eP‘‚?%§˜¸’s¿mñ&H7…Ÿ?"´Á·è¿U¥]ç÷œ¿_K#Á¯ì‘?^á½ ö ¿‘vµrµi¿Õ+ˆ(ö5–¿8@¼ğ{‚«¿cß’?¿¿Œ?†&­YZ?İ*K– °¿E:à¦¿ln3²·Ö¡¿ ÓP3›b¿¶ß£?e…_@è¥?T…ÿ¬­¡¿Çl:ÍÅ™¿|V5#ìä¿©!	i¿«òÃ\à_›¿=š\åF¤?drûsh¿.ßc¿‹HGK{	?=<å‡!¿.Cók±ü™¿jAS:¢?bé¸$K	š?fO–#jşe?hÏ@WÓ¸?óÊ³šÇÄ¤?Dh’Åî•¿g:˜”v¿EàÒÖ-µ?¼sj_'’§?%Î,7ˆ>†?òr,}U•¿Å… .­?øæLí0?²ı#‘?Õ°¹LH‰?kÏø¢c•¿Ü,˜f‘?©s^ÆÁc¥?/ô˜¤Å’¿y óßoóŸ?z*Tõú¬´?Õ-^ÓS©?éG¢ŠĞ±?n­ü 5g?óYwg´?%³`£¿ÈûÄC”¿O”ì'O˜¿BéY‹‰³¿­Q¬¦-¦¤?WBóø‰„?IJ¥˜¶‘?®Ñ ÎŸ¿/ö¹~cFn?–İk¿· ¿Š+òáe¥?Í&A1´¿ñ"ğàWG”?‚‚{3¤i¦¿b4nß’¿÷2Ú‘‡i?×ñœƒ ¿ÑıˆÊ ?¦‹p:™?×ÉÊCg¢?A}œˆ=v@?›f t·¿N®P«§?ÃCÍªB¿Tç5œP ?|¸
€öÅ£¿ı¤¢ı„½«?¿¶Ÿ¹¡?şwä¾,¿\z,dKâ”¿Dôs\ğš¿B“'½-`µ?-›zVÜ¿]?®!ùÉ§?f%Ñ¾ş“›?:Ç2¿l]çx¨?¨”®Ë¶ô´?)5bu¢?#¸‚‡–¿zvâ:¤”¿°
«ã¾ö¯¿o«†èš¿%ñï¼z¥?`à ZĞ½£¿fûó˜`?ùR;Yˆ¿ñÿÄwK:‚?Äj ·?r‰#D°?‰Hù»
8ª¿Ë:¿
ëˆ? ßRŒû¨¿°"; ß­?& w(B„¿B¹§Š-·?%éØÙæ‡?["TÿÙ¼‡?ÖàHc^ª?ĞŒ™˜²„¿	±¹¾±¬¿Ó¯?ña8Ï¿ú›¿Çë@$ã®?‡åü¥)£?_MØ]$İ˜?¢!ğ{,a¬¿TìÅ§Yp¿°°ôb§¦£¿I=9zd¿‹iP{äk?…Ê€½Ú…=?Ûˆfj…?âÊÙ;£­ ?-VıßK@µ¿~a‘,NO?İM©CU§¿£t“_Ùáˆ¿i³TXU¡˜¿ÿLZû6Ùj¿³ïHÄ­åª¿$ª¿w~³¿›CEá"¡¿ó$á)†?0DıĞW?Œ{Ú~…š¿@İØ!`?¥šç½Ñ‰?,=†Í|ª¿™`æ ?VxÀ
*‰”?Äâ=İ¡¦?¢n5%8yª¿6e© ƒ?zåö¢¨•¿£Í½üX«¿Ó´û½cd°¿¼«wèV0c?_Â1c»’?zŸ²³K˜¿Rw¥ß•? ›bÄôs?=eOfQ³¿w8ù®ºn‹¿úÄK\°¿P]ı3’¿£»0A)4¥?!ÖH6J£a¿®ö¿B7¿{â¿”˜?Œéš­â™?n>Ñ)À—?Š›ƒ,Š“?×XR†[Rœ?óVõ£õx¤¿èÒ$#X”¿ô­o]º¡?Ò^ñ’;”?f–ÄşW³¿Šç®s;©¿e+£Eˆ«?ıûÓbŠ?}ƒ'Û]ó–?hÛÖx£]?Z@â­S–?‹»áA*ú­?ü[¤~N©¥¿ÿÚà•;kƒ¿CÖ åŠ›¿kÆ"õº™?Òæ´~e§?Ûš|Ìj.°?†– â?–²Å› İ¡?úÎ*‘÷‹¿VQ&¯z2Š?ˆ¾V! A{¿FHàFu?’\âîÊ3?³4CìD§?È~’íğŒ¿¥—ÿ-T@B¿º‘Ğ›,ã¡¿Î~rNË“¢?!DP:3ïX¿xÁpF~Ÿ¿ñ½;	×i©¿$qÆ˜
İ–?Uœ|ˆ+}?"io¤÷ƒ›?“ˆD/õ„¿¨2‚rnr?¸İ]>ha?û±bòi‚?ÎJâ²¢?³WL"CÒx?Ú«Mkìu²?»·Høã˜?ùã`°Ç˜¿bŞ€"XM²¿]ï¸Uª¿7ª¤Qfc?Šø“ Û%¢¿õA‚!,Üb?+Šô. ˜?ÜĞÑ —-¬?"ãQ*á	«¿Üßí¤„¦¿Ñbtp²?€H‚[Ÿ?j™wb÷™?ßıñ^µ2±¿dND}š¬§?³˜uR¡²¨¿¨àytæÈ¿¹>bªO(¦¿X†m0y¤¿-YGb=š?Û&=Uƒƒ¿ç«[r?ˆ]/Û»÷¿€ù\T(^±¿(æ# ÷{¿GV¤à.ª?[6h“Û’¿bà¢[ûw“?w£ÁÜ´†¿Ò{?Bˆ¥¿vuº8™Ô’?¸½:Mº›?èEõï]÷¶¿æv*>é‹?ÿÁd©?˜ìü¾k‘¿éÈÛ[Ûª?ı)l>b‘¿G6º=˜?#Bé¸­¿*1»fsN€?#’ºË?¸†^î¯øw¿§ı/tx±?oËJ
arq¿7æĞ}”„¿~6‚Ûz ¿	‰hÿù9?W%AUØ„¿hxK#zÚ§¿Ÿ‚pÃ÷”¿r\`­ß¿‘k\bÙŠ¡?:¿&@TçŸ?^;°$F…?íşl<¼x¿kwcÏŒ?Bùy¸;¿¼`"*s¿AÍ¹©»‘¶?‹ôG½L¹Ÿ¿5´‚˜e¨?~—u¦ @W¿%Ú"U
t?_™ÑŠ•¿º}L—?°T8şæ¥¿®/&¾YÑ–¿wØ±]ª©?ˆúÙŸö¡°¿™\Şìt¥¿oå™U§¦¿[$Ì86Ğ’¿ïÛ÷E•£ª?ƒY1ô9‡¿ªH¦¿nC¥?	^9#9à?Æâ½¾dˆ?ÒW-<q1¯¿:>4Õ@Š?å÷İ†®’¿l½{­o¢?*˜^†òr?îÖq}Ñ~£?İEşO¨?-cê~³l’¿Qóv ›Ş ¿Ä±âß]ê¿åIá`À¥?PZA³¿	™İóùu¿}4@®0¨¿®p†sñİ„¿ØÔšbå¿™~‰xëüµ?’_2š‹•?Ón=@€¤?
¬ıL¦Òk?÷\"î¥¿cpPŸ=Ç¦¿Ò^ K­¿QVœJW•¿Ê<6% Ï™¿x@$–?(CŞ=¦¿Îæè&nkˆ¿iI$*„’¿Q‡=€?¬[şyZ@?ÙØÍ•·X¿= ¨Ñæc¿dô¬ŞÀµ¿¿üÂé,Ì…¿VâŞ|öz¿s³¯¤+ÄŠ¿0Å\Ä’?¼½Óü+†g¿j%ß2ÈÙ“?w‚ø¦¿~ù?Ås¿ŒËÏ¨!ƒ?¨«ùù_Œ¿	’†9’âŸ?íS¶‘°t¿õ©[É¢¿êÆIMú„?z¹”bc8Œ¿ù¹úá‚”i¿†òŒWš¬¿ğLÙå š?õÅzW¿ŒàmHÉ—?¯Ç
Ÿ)K¥?¥³Ì@ ?ô Vâ®¿À^·Á¶iw??ß»rb´—¿“V[5ø¤?İè„L	ó¶¿ı¤˜‹ì¤?moşù’š“¿d(`7Ÿ?Œ"'ğ§ö„?ô#Ââ.˜?Ÿ‰ÁŸ€6u?O‚Ÿ-v¿3õ{á¢?”3÷ügÇq?V«e!ğö°¿Óùú´?QÏ4Ámö†¿×©”Ì!¿t7,f´`¿h½Óõ¨?"ÕË}ß°v¿µû_òbš¿Yç}»£™¿5=Ãü^ª¿–e9‰“¿’û¸^Z¡¿lpÇ@C$´¿šFÈ}š?ú<-ÜEÚ?ul–„q¿°ÆÏ‘ ¿ıb¨?×úĞGŸ¿ó¢7[ÇX˜?±†î>°?R±Ë<—¿b«Û’_¥¿_j00§?’‡<„T¡¿Ä†ûÄµf¿dqÅæ_¢œ¿ä-ÄÛdª¿Yõ =êñµ?¡!×Ş‹U¿˜Çbçây™¿3İ]ú¦Ï™?ÔzC
3¨?kz7³éJ˜¿&æğ@‘¤x¿òİZä¦Ÿ?À½BQf¤?(ø¿†T¦?ä—ê—Âbœ¿C‚‘¿•EÔó‘?Ô,+¨´˜¿$À¿Û˜ ?Ä>d>Ş³¤¿iZÂ×`¬œ?	¼kLü>,Ì‘{”¿iG#ÿÉˆ?(îÛ½š—¿:öVìØ©?Gà¾÷ÿ½?{Ú¾²=«¿gZJí¸.[?£,Sş{°?I}/ ‹¯?PqGø™?6èsÅ÷‹¿Ä;Ìœ¿¥X#a^¬?ÉğĞ^ ?X£VL0’q?LÈ]=T>¤?ñ–gä?Şô’”.±?›®w­ô¿)cçl•¿—ˆÄøÁİ?‚1œ™“?Û„&ö°?¼Œj*îì?H÷'|¬œ‚?‡2.ş±n§¿oêfİiM¿®©Án·©¿ú÷_Õ ?·ıt³§?Ê÷} ?ÄÏºuŠ?’z‚œÊr?¡ú .­Dª¿=ˆ¶Æj›?h±±œ™Ÿ?l…~à	•¿™=;¦Ù™?’_aî-£?ÉRy¨^?mµ"M@x¿{ª}‘¿6õ5Ÿwq?»cµ‡?¹8â!‘Œ¿ú/D˜ìª¿ø6»½½Î¢¿%‡s 	2¦?<èó ÿ\¤?Ø‚œÿ¢¿9%A4Êe?›]6»g½™?ğbÑÜY§£¿í>]cë§˜¿Y(PÆ#±Ÿ?ı qz~?’tn3°?“áx>ê?œöÌFrï“?ST¢‘tr‡¿üb¾£?SƒùÃ€9¤¿Yƒ(ıÌw¿‚ˆ¤{u˜¿X”+ö ¯?*Ùû¢4?{`ÏğÉ7¡¿85|}@¯”?|È¾@ÎL?añåOeb¢¿ôºµ"A³¿™âîÏìŠ?6}MAD‹?9zèú¿œ‘¿çZ‚kr¿m7–·ğª?Œh¥í¸—?#§^	®?ø£Áƒ¿­¿
`Ò1JD°?ÄÓ§,uVœ¿M“^CŒ¬¿ç=Jü¼o¤?™üUÎƒ¿˜‚h¿K/—¿º7–âpv?xsš !˜¿gİ»¤¿ƒv„\tu™?FÃH€±ö“?‹Kú p°?´´CğM?æ7wıÃ‹v¿Kj;‚(S‘?ş5wùx˜¿£¸,$5ô„¿G}M=°V?­@ùPj‹?KÂÙ;˜¿T·?­¬¿óïé «¿‹‚>cï]­¿t¶÷Ş´?€:@š¿ŞŒ‹„eUt¿W‰xáŠš¿]ƒ¸ì¼“¿šù@¸# ?Ú-—Çyƒ?¬>–¿ôV®¿sÑ|Bò¿Ää@!˜¿bõmß¨·Œ?œ!Ç xr?e ù)ÆŸ¿ş·q2^}?$¶ƒgû§¿kiw¿$Í,ıÜ´—¿+²ç|Â#¬¿®•O·–?ÜÏW »é©¿¨Ò¹[A¨¿”:¼x#•?øœÜ§¯?ÄÉGé²?#@—ºu?„™‹ÿ±¡¿~%g“‰–¿ë¸NL¬¢¿ö¥˜2Y¿–ö«P¨?ê®Tf6i?¹ŞİD“?=Şyåä«¿ø[n¢?ü(/¡‡?]%í€Ê|°¿-HÚ]Ğ˜¿l
½?st/eœG?½¬¾÷hŒ¿™‡lœ?èZáôY©?ïs`_	© ¿‡æV™Ä8b¿xk$ÿO¢f?CMÛ\ˆt¿¥T,ø‰ƒ¿æ=ûJŸ?À»Fße‡?ïûšY	å?—.4?M¿È\Ò~í™¿g?÷Š„¿fè½Èûe]?ïp¿lĞÑ£¿šÈ’Z¤˜¿2Û€•d™¥?%¢Ù+âz?=Ãiû6HŸ¿ä’êÎƒ‰?…ÔL‚q?Á× :C•¿á™Ğ$±¤³¿İjÓaPi§?o_Iêë– ¿’İf˜<X]?ã{î Pß¥?ôæ®h‚?‰ àÛ³?È&¬^T?oì]¬=&§?ÖdøŒ¬?—szõ){Š?UnóİåÖ¡¿õ@âşóY¿ğ”OMQ¥?—Hlîr‰?Ÿ­ÀI ¦?ÍVT€Ì'«¿¦cÂ;=¬¿·ÿ1Œª¿e
J®ë‚?c˜ù>·¿…¥ ,“q¿»=µÙ«?'|Ä]5¾c¿„¯·æñ(¡¿Ã¼¦‹=I°¿çêµC=)¥¿¼]/MàŒ?éñ	FJ™?H"¼£??7¦ºÂœ¿Öëí€„·¿évøÎÜ§?›^œ×\^”¿€ö<âd©?Wb\yâœ?Eª³Pîˆ?·1°mÕŸ?šGÁıÇÜ‘¿q7N+¨?-ëaÜË…²¿[	zûµí”?ŸH@ˆ„¿DÂv©¢?“J¡Áày¦¿/í€¤µ¡¿Wùì y^­?ßæC¨¯?î};ĞR?¹î/€Å!ˆ?+<ø! s¨?›a³?Â.Œ¿œkÿº`¿Ë(­÷Ï^•¿Ú9?XÕ±“¿mù3An-e?MŠ@	ô¬¿gÉÅŸ?z<®¿…r[?K Ş á˜?B&¶P²¿xó´ùÇŸ¿{x¿ŸTÚ–?²'ß>;¢¿“óÍOÔF¯?±º,Õîƒ¿—55ùûÿ¥¿¹—£ã„?| $Cßô’?ü²DÿµĞv¿mÁZÎã£??ìÎØlìƒ¿Évéw#¡¿î~–`Ñª²?Ó%b?u¿Èiı¥4¿[?|äİÆµ¬?(ïÈ"÷\.¿v$ü*w¡t?-¢»^y¿``t~,r™?S&îŞu)š¿fVzcÄâœ¿Ä$¿òŞ °¿‹Hö|‰‘?r®ù«¶·?ÖXÊB|k¿EÓŸWú¦¿W½JŞëq?o<ÃÇl¿.@ùÀ0¥?$éÍºÜæ—¿âpN;èQ”¿å Ãıùƒ?¾k¾´"?¯È.ŸL¦“¿B6+PŠ¡?%!âığ§•¿Ùy!yüYb¿ñ^—Ü†#„¿‰ÎNà&Œ¿†,ì@À–¿˜½l;m¤¿í¥Õ°U¿¸VvRœ¡?pwßkg°¿*~ĞÖh	‡¿y(øÎS‹?r»>Œ¼gN¿UF§×ûÇy¿/
/=¨?jn"†_â¨?ûı•§	aŸ¿;:®Fv¥•?
”&aƒš?'õ
°4•³¿ÕFûs_;?•ÍEŒb©?j³a¨£}?iñü~>…–?’¥½^íjv¿*ûSO‹f®¿îAWq?Ü–Õr?új`/FŒ?Ng}ƒ\Í¡?}ß¿Â¸r?R(Wí¤Š¿VÁ@)®¿ÎˆÒŞà¡¿K}¢°`¬¿E­âí>P?#à­„§¿¥LıËÔuw¿Ş¤Õ?•Y)©¸ ¿“ÚÃš€?ÈùFø¥¿HáÆ¢ó^p¿¾`]G·V?ê™¹Ÿ$¤¿oÙ[©ë§?0!|®
¬¿©>’½âœ¿K±;Ş‘?·+ùzì”?•Ü›¾"è³?Bù_şR‡¿â(	!Ñœ¿áü<üëË©¿~—‘ûÏú¿4Y½r¦ÑŒ¿
LÈƒ÷§¿KO¼t¿¿Á0Ãóµ¿mÊ²³*º¨?î4Âpèµ?,^5¢ş2p?\™èÚ¹?ùóÎ¡Ã5k?y{k»d§?Å‰ñ§¿:ş¤Au?UˆwüF…?6ŒE¿ÃZm&ıŠ¿¸9             È9                     # Avalanche Quick Start - Crabada NFTs  The goal of this quick sğQ      0R      # Avalanche Quick Start - Crabada NFTs  The goal of this quick t@R      €R                      èQ             0R             €R             v   
content ÿÿÿÿÿÿÿÿÿ*string8
3vector ÿÿÿÿÿÿÿÿÿ*fixed_size_list:double:7688j
lance0.17.0z
lance0.1{   Ğ¥ È£*m
0 ÿÿÿÿÿÿÿÿÿ*struct

null_count*int648
	min_value*string8
	max_value*string8 ¥JS         LANC